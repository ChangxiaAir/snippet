
算法分析与设计
===========

## 一、总述

### 1、何谓算法（Algorithm）

通俗的讲，算法是指解决问题的一种方法或一个过程。严格的讲，算法是若干指令的有穷序列，满足性质：

	(1) 输入：有零个或者多个外部量作为算法的输入。
	(2) 输出：算法产生至少一个量作为输出。
	(3) 确定性：组成算法的每条指令是清晰，无歧义的。
	(4) 有限性：算法中每条指令的执行次数是有限的，执行每条指令的时间也是有限的。

### 2、何谓程序(Program)
程序是算法使用某种程序设计语言的一个具体实现。程序可以不满足算法的性质(4)即有限性，例如操作系统，它是在无限循环中执行的程序，因而不是算法；然后可把操作系统的各种任务看成一些单独的问题，每一个问题由操作系统中的一个子程序通过特定的算法实现，该子程序得到的输出结果后便终止。

### 3、问题求解(Problem Solving)

算法设计的一般过程：

	(1) 理解问题
	(2) 了解计算机设备的性能
	(3) 在精确解法和近似解法间做选择
	(4) 确定适当的数据结构
	(5) 算法设计技术
	(6) 详细表述算法的方法
	(7) 证明算法的正确性
	(8) 分析算法
	(9) 为算法写代码

### 4、算法复杂性的分析与设计

	算法复杂性 = 算法所需要的计算机资源（包括时间和空间）。
	算法的时间复杂性T(n)；
	算法的空间复杂性S(n)；
	其中n是问题的规模（一般指输入大小）。

#### 4.1 算法渐近复杂性

t(n)是T(n)的渐近性态，为算法的渐近复杂性。

在数学上， t(n)是T(n)的渐近表达式，是T(n)略去低阶项留下的主项。它比T(n) 简单。

#### 4.2 算法的效率

一个算法的最差效率：是指当输入规模为N时，算法在最坏情况下的效率。

一个算法的最优效率：是指当输入规模为N时，算法在最优情况下的效率。

一个算法的平均效率：在“典型”或者“随机”输入的情况下，算法会具有什么样的行为。

	(1) 最坏情况下的时间复杂性
		Tmax(n) = max{ T(I) | size(I)=n }

	(2) 最好情况下的时间复杂性
		Tmin(n) = min{ T(I) | size(I)=n }

	(3) 平均情况下的时间复杂性
		Tavg(n) =

	其中I是问题的规模为n的实例，p(I)是实例I出现的概率。

#### 4.3 分析、求解算法复杂度的方法：

	(1) 根据循环来统计基本操作的次数；
	(2) 利用递归关系来求基本操作的次数；
	(3) 利用平摊的方法来统计基本操作的次数。

#### 4.4 进行算法分析的数学基础：

	(1) 典型的求和公式；
	(2) 积分近似求和；
	(3) 递归关系。

注：以上内容参考自《算法设计与分析》（王晓东）。


## 二、渐近标记符号

`Θ（西塔）`、`O（大写字母O）`、`Ω（大写“欧姆”）`、`o（小写字母O）`、`ω（小写“欧姆”）`。

### 1、渐近分析的记号

在下面的讨论中，`对所有n，f(n) >= 0，g(n)>=0`。

#### 1.1 紧渐近界记号Θ

`Θ`记号渐近地给出一个函数的`上界`和`下界`。

	Θ(g(n)) = { f(n) | 存在正常数c1, c2和n0，使得对所有的n >= n0，有：0 <= c1g(n) <= f(n) <= c2g(n) }。
	对任何一个函数f(n)，若存在正常数c1，c2，使当n充分大时，f(n)能被夹在c1g(n)和c2g(n)中间，则f(n)属于集合Θ(g(n))。

因为`Θ(g(n))`是一个集合，可以写成“`f(n) ∈ Θ(g(n))`”，表示`f(n)`是`Θ(g(n))`的元素。

对于所有的n >=n0，f(n)在一个常因子范围内与g(n)相等。我们说g(n)是f(n)的一个渐近确界。

Θ(g(n))的定义需要每个成员f(n) ∈ Θ(g(n))都是渐近非负，也就是说，当n足够大时，f(n)是非负值。这就要求函数g(n)本身也必须是渐近非负的，否则集合Θ(g(n))就是空集。因此，**`假定Θ记号中用到的每个函数都是渐近非负的`**。

#### 1.2 渐近上界记号Ο

`O`记号在一个常数因子内给出某函数的一个`上界`。

	O(g(n)) = { f(n) | 存在正常数c和n0，使得对所有n >=n0，有：0 <= f(n)<= cg(n) }。
	f(n) = Θ(g(n))隐含着f(n) = O(g(n))，因为Θ记号强于O记号。按集合论中的写法，有Θ(g(n)) ∈O(g(n))。

#### 1.3 渐近下界记号Ω

`Ω`记号给出函数的渐近下界。

	Ω(g(n)) = { f(n) | 存在正常数c和n0，使得对所有n>=n0，有：0 <=cg(n)<=f(n) }。

定理：

	对任意两个函数f(n)和g(n)，f(n) = Θ(g(n))当且仅当f(n) = O(g(n))和f(n) = Ω(g(n))。

定理：

	Θ(g(n)) = O (g(n)) ∩Ω(g(n))

#### 1.4 非紧上界记号o

`o`记号表示非渐近紧确的上界。

	o(g(n)) = { f(n) | 对于任何正常数c，存在常数n0 >0，使得对所有n>=n0，有：0 <= f(n) <= cg(n) }。

O记号与o记号的定义是类似的，其主要区别在于：`对f(n) = O(g(n))，界0 <= f(n) <= cg(n)对某个常数c > 0成立；但对f(n) = o(g(n))，界0 <= f(n) <= cg(n)对所有常数c > 0成立`。从直觉上看，在o表示中当n趋于无穷时，函数f(n)相对于g(n)来说就不重要了，即:`当n -> ∞，f(n) / g(n) -> 0`。

#### 1.5 非紧下界记号ω

`ω`记号表示非渐近紧确的下界。

	ω(g(n)) = { f(n) | 对于任何正常数c>0，存在常数n0 > 0，使得对所有n>=n0，有：0 <= cg(n) < f(n) } 。
	f(n) = ω(g(n))等价于“当n -> ∞时，f(n) / g(n) -> ∞”。

### 2、渐近分析记号在等式和不等式中的意义

`f(n)= Θ(g(n))`的确切意义是：`f(n)∈Θ(g(n))`。

一般情况下，等式和不等式中的渐近记号`Θ(g(n))`表示`Θ(g(n))`中的某个函数。

例如：`2n*n + 3n + 1 = 2n*n + Θ(n)` 表示`2n*n+3n +1=2n*n + f(n)`，其中`f(n)`是`Θ(n)`中某个函数。

等式和不等式中渐近记号`O`,`o`,`Ω`和`Θ`的意义是类似的。

### 3、渐近分析记号的若干性质

#### (1)传递性

	f(n) = Θ(g(n))   g(n) = Θ(h(n))    =>   f(n) = Θ(h(x))
	f(n) = O(g(n))   g(n) = O(h(n))    =>   f(n) = O(h(x))
	f(n) = o(g(n))   g(n) = o(h(n))    =>   f(n) = o(h(x))
	f(n) = Ω(g(n))   g(n) = Ω(h(n))    =>   f(n) = Ω(h(x))
	f(n) = ω(g(n))   g(n) = ω(h(n))    =>   f(n) = ω(h(x))

#### (2)反身性

	f(n) =Θ(f(n))    f(n) = O(f(n))    f(n) =Ω(f(n))

#### (3)对称性

	f(n) = Θ(g(n))当且仅当g(n) = Θ(f(n))

#### (4)转置对称性

	f(n) = O(g(n))当且仅当g(n) = Ω(f(n))
	f(n) = o(g(n))当且仅当g(n) = o(f(n))


注：因为这些性质对渐近记号也成立，我们可以将两个函数f与g的渐近比较和两个实数a与b的比较作一类比：

	f(n)= O(g(n)) ≈ a <= b；
	f(n)= Ω(g(n)) ≈ a >= b；
	f(n)= Θ(g(n)) ≈ a = b；
	f(n)= o(g(n)) ≈ a < b；
	f(n)= ω(g(n)) ≈ a > b。

	如果f(n) = o(g(n))，则f(n)比g(n)渐近较小；
	如果f(n) = ω(g(n))，则f(n)比g(n)渐近较大。

### 4、几种复杂度比较

n	|Logn|	n	|nlogn	|	n^2|n^3	|2^n	|		n!
----|----|------|--------|-----|-----|-------|------------
10	|3.3|	10	|3.3*10	|10^2	|10^3|10^3	|	3.6*10^6
10^2|6.6|	10^2|6.6*10^2|10^4	|10^6|1.3*10^30|9.3*10^157
10^3|10	|	10^3|1.0*10^4|10^6	|10^9| |

注：`nb = o(an)`，任何底大于1的指数函数比任何多项式函数增长得更快。

说明：以上内容参考自《算法导论》。


## 三、递归

### 1、递归的定义

用函数自身给出定义的函数称为递归函数。直接或间接地调用自身的算法称为递归算法。

用数学公式来表示递归（函数或算法）的式子叫做递归式。

### 2、递归的原理

关于递归运作的原理，说白了就是一个栈的问题。递归的底层是用栈来实现的，要想理解递归，就得需要理解栈的运作方式。栈是一个先入后出（或者说后入先出）的数据结构，关于栈的问题，请参见数据结构中的栈内容。

从表现形式上来看，递归就是一个有一个或多个递归出口且调用自身的函数。

### 3、递归的两个要素

递归函数的两个必要的要素：**_边界条件_**与**_递归方程式_**。

边界条件就是一个递归函数停止调用自身的判别式；如果到达判别式，就停止递归调用，否则，就继续递归调用自身。如果缺失此项，则就会形式无限递归调用，最终计算机中的栈被全部使用完毕，而导致递归调用失败；换句话说，如果没有边界条件，那么该递归基本上可以说它一定会调用失败。

递归方程式就是一个在数学上的用函数自身（参数不同）来表示自己的函数，即上述据说的递归式，它是指导写递归算法的公式。如果找不出该递归方程式，估计也就没有办法来用递归求解了。

### 4、用递归来求解问题

要想用递归来求解问题，首先要对问题进行分析，找出该问题的边界条件和递归方程式；然后要论证该递归方程式是否正确，即要证明该递归方程式（此步骤可在纸上或腹中进行；如果能够保证该递归方程式正确，也可以直接省略）；最后根据边界条件和递归方程式写出递归函数。

用递归求解问题的关键部分就在于边界条件与递归方程式的分析，换句话说，用递归思想求解问题的工作就是找边界条件和递归方程式，二者找到了，也等于递归函数写出来了。

### 5、递归的复杂度

递归算法的时间复杂度是`O(2n)`，空间复杂度为`O(n)`；非递归算法的时间复杂度是`O(n)`，空间复杂度是`O(1)`。

### 6、递归的转换

递归算法易设计，但执行效率较低，常要转化为非递归程序。

递归算法的非递归实现通常有三种实现方法：利用栈消除递归，利用迭代法消除递归，利用末尾递归消除法消除递归。

### 7、常见的递归问题有

`阶乘`、`斐波那契数列`、`Ackerman函数`、`排列问题`、`整数划分`以及经典的`汉塔诺问题`等。

### 8、其他

在使用递归求解问题时，要注意递归的层次；如果递归的层次过多，则栈的空间可能不够用（即栈溢出），从而导致递归求解失败。例如：如果一个计算机的栈空间仅允许递归10层，那么就无法使用递归来求解12的阶乘，因为没有栈空间来保存第11次递归调用时的局部信息，相当于栈溢出。

### 9、示例

#### 9.1 n的阶乘

##### (1)分析问题，找出边界条件和递归方程式：

	边界条件：如果n = 0，则n! = 1；如果n = 1，则n = 1。
	递归方程式：n! = (n - 1)! * n。

##### (2)根据边界条件和递归方程式写出递归函数：
```c
int fun(int n)   // 该函数求n的阶乘
{
	if (n ==0)   return 1;     // 边界条件：如果n = 0，则n! = 1
	if (n ==1)   return 1;     // 边界条件：如果n = 1，则n! = 1
	return  fun(n-1)*n;        // 递归方程式：n! = (n - 1)! * n
}
```

#### 9.2 Hanoi（汉诺塔）

设a、b、c是三个塔座。开始时，在塔座a上有一叠共n个圆盘，这些圆盘自下而上，由大到小地叠放在一起，各圆盘从小到大编号为1，2，…，n。现要求将塔座a上的这一叠圆盘移动到塔座b上，并仍按同样的顺序马叠置。在移动圆盘时应遵守以下移动规则：

	(1) 每次只能移动一个圆盘；
	(2) 任何时候都不允许将较大的圆盘压在较小的圆盘之上；
	(3) 在满足前两个规则的前提下，可将圆盘移到a，b，c中任何一个塔座上。

##### (1)分析问题，找出边界条件和递归方程式：

关于汉诺塔问题，也可以用递归来解决，但是有点难以理解，并且也难以用手工移动来模拟该算法。为了更加简单的理解该算法，要运用面向对象的观点，即把每次的移动都看成一个整体对象，而不管其内部细节。

**事先说明：**

	函数void hanoi(int n, int a, int b, int c)表示把塔座a上的n个圆盘(即编号从1到n的圆盘)移动到塔座b上，塔座c为辅助塔座。
	函数void move(int a, int b)表示把当前圆盘（即编号为n的圆盘）从塔座a上移到塔座b上，此函数应该在函数hanoi中调用。

**边界条件分析：**

	塔座a上只有一个圆盘（即编号为1的那个圆盘），直接将编号为1的圆盘从塔座a上移动到b上。

**递归方程式分析：**

	如果塔座a上有多个圆盘(假设有k个，即编号从1到k)，那么将编号从1到k-1的圆盘看成是一个整体(即一个圆盘，为了说明，在此记为x)，
	并把它移动塔座c上，然后把编号为k的圆盘移动到塔座b上，最后再把塔座c上的x移动到塔座b上即可；至此为一个递归调用。

##### (2)根据边界条件和递归方程式的分析，写出递归函数：
```c
void hanoi(int n, int a, int b, int c)
{
	if (n ==1)  move(a, b);   // 边界条件

	// 递归方程式
	hanoi(n-1, a,c, b);
	move(a, b);
	hanoi(n-1, c,b, a);
}
```
由此可见，有时利用面向对象的观点，或许更容易理解问题。


## 四、分治法

### 1、分治的原理（即基本思想）

将原问题划分成n个规模较小而结构与原问题相似的且相互独立的子问题；递归地解决这些子问题，然后再合并其结果，就得到原问题的解。分治使用的是自顶向下的方法。注：由原问题划分而成的子问题可以相互独立与可以不相互独立，但是，一般要求相互独立；如果不相互独立（即子问题相互重叠、重复），虽然也可以用分治法来求解，但为了效率（即避免重叠的子问题多次求解），应该使用动态规划策略来求解，而不是分治法。

### 2、分治在每一层递归上都有三个步骤

	分解（Divide）：将原问题分解成一系列子问题；
	解决（Conquer）：递归地解决各个子问题；若子问题足够小，则直接求解；
	合并（Combine）：将子问题的结果合并成原问题的解。

### 3、分治法的一般的算法设计模式
```c
divide-and-conquer(P)
{
	if (|P| <= n0)  adhoc(P);
	divide P intosmaller subinstances P1, P2, …, Pk;
	for (i=1;i<=k; i++)
		yi = divide-and-conquer(Pi);
	returnmerge(y1, y2, …, yk);
}
```

### 4、常见的分治法问题有
`二分搜索技术`、`大整数乘法`、`Strassen矩阵乘法`、`棋盘覆盖`、`合并排序`和`快速排序`、`线性时间选择`、`最接近点对问题`、`循环赛日程表`等。

### 5、其他
运用分治法设计出的程序一般都是递归算法，但也不尽然。

### 6、示例

#### 6.1 二分搜索技术

#### 6.2 合并排序

#### 6.3 快速排序


## 五、动态规划

### 1、动态规划的原理（即基本思想）
动态规划的基本思想与分治法的基本思想基本上类似。将待求解的问题分解成若干个全部或部分重叠的子问题，先求解子问题，但在求解这些子问题时只求解一次，然后从这些子问题的解得到原问题的解。

### 2、动态规划与分治法的相似与区别
虽然动态规划与分治法基本相似，但还是有点不同。动态规划与分治法唯一不同的是：由原问题分成的子问题部分或全部重叠、重复；在求解时，这些重叠的子问题仅仅被求解一次，而不是多次。换句话说，分治法适合于求解子问题相互独立的问题，而动态规划适合于求解子问题重叠的问题。当然，对于子问题重叠的问题，使用分治法也是可以的，但是效率不是很好，因为重叠的子问题多次被重复求解。

分治法算法是指将问题划分成一些独立的子问题，递归地求解各个子问题，然后合并子问题的解而得到原问题的解。与此不同，动态规划适用于子问题不是独立的情况，也就是各个子问题包含公共的子子问题。在这种情况下，若用分治法则会做许多不必要的工作，即重复地求解公共的子子问题。动态规划算法对每个子子问题只求解一次，将其结果保存在一张表中，从而避免每次遇到各个子问题时重新计算答案。

### 3、动态规划的两个要素
采用动态规划方法的最优化问题中的两个要素：最优子结构和重叠子问题，即问题必须具有最优子结构性质以及其子问题必须全部或部分重叠。

从一般意义上讲，问题所具有的这两个重要性质是该问题可用动态规划算法求解的基本要素。

#### 3.1 最优子结构性质

**`如果问题的一个最优解中包含了子问题的最优解，则该问题具有最优子结构。`**（当一个问题具有最优子结构时，提示我们用动态规划可能会更适用。）

在动态规划算法中，利用问题的最优子结构性质，以自底向上的方式递归地从子问题的最优解逐步构造出整个问题的最优解。也就是说，首先找到子问题的最优解，解决子问题，然后找到问题的一个最优解。寻找问题的一个最优解需要在子问题中做出选择，即选择将用哪一个来求解问题。问题解的代价通常是子问题的代价加上选择本身带来的开销。

#### 3.2 重叠子问题
适用于动态规划求解的最优化问题必须具有的第二个要素是子问题的空间要“很小”，也就是用来求解原问题的递归算法可反复地解同样的子问题，而不是总在产生新的子问题。**`当一个递归算法不断地求解同一问题时，我们说该最优问题包含重叠子问题。也就是说，不同的子问题中又包含了相同的子子问题。`**

相反地，适合用分治法解决的问题往往在递归的每一步都产生全新的问题。动态规划算法总是充分利用重叠子问题，即通过每个子问题只解一次，把解保持在一个在需要时就可以查看的表中，而每次查表的时间为常数。通常，不同的子问题个数随问题的大小呈多项式增长。因此，用动态规划算法通常只需要多项式时间，从而获得较高的解题效率。

### 4、动态规划所适合求解的问题
动态规划适合于解决`最优解问题`。

### 5、动态规划算法的一般步骤
动态规划算法的设计可以分为如下4个步骤：

	(1) 描述最优解的结构或性质；
	(2) 递归地定义最优解的值，即建立递归关系以便指导下一步的最优解的值的计算；
	(3) 根据上一步的递归关系，按自底向上的方式计算最优解的值（该值是下一步构造最优解的依据）；
	(4) 由上一步计算出的结果构造一个最优解。

第1-3步是构成问题的动态规划解的基础（或者说基本步骤）；在只需要求出最优解的值时，第4步可以略去；若需要求出问题的最优解，则必须执行第4步。如果的确做了第4步，则有时要在第3步的计算中记录一些附加信息，使构造一个最优解变得容易。

### 6、常见的动态规划问题有
`矩阵连乘`、`最长公共子序列`、`最大子段和`、`凸多边形最优三角剖分`、`多边形游戏`、`图像压缩`、`电路布线`、`流水作业调度`、`0-1背包`、`最优二叉搜索树`等等。

### 7、动态规划加速原理

### 8、其他
动态规划是求解某类问题的一种方法，是考察问题的一种途径，而非一种特殊算法，故没有一个标准的数字表达式和明确定义的一组规则，必须对具体问题具体分析处理。所以，除对基本概念，方法，正确理解外，应以丰富的想象力去建立模型（递推关系式），用创造性的技巧去求解问题。

### 9、示例

#### 9.1 矩阵连乘

#### 9.2 0-1背包问题



## 六、贪心算法

### 1、贪心算法的原理（基本思想）
贪心算法通过一系列的选择来得到问题的（最优）解。它所做的每一个选择都是在当前状态下局部最好的选择（即贪心选择）；换句话说就是，对于算法中的每一个决策选择点，做的是当时（看起来是）最佳的选择。也就是说贪心算法并不从整最优上加以考虑，它所作出的选择只是在某种意义上的局部最优选择。

但是，**`这种启发式的策略并不总能奏效，然而在许多情况下确能达到预期目的，即找到最优解；虽然贪心算法求解的结果并不总是最优解，但有时候，其最终求解结果也却是最优解的很好的近似解。`**

### 2、贪心算法的性质
贪心算法具有两个重要的性质（或者说是基本要素）：**_贪心选择性质_**和**_最优子结构性质_**。如果我们能够证明问题具有这些性质，那么就可以设计出它的贪心算法。

#### 2.1 贪心选择性质
所谓贪心选择性质是指所求的问题的整体最优解可以通过一系列局部最优的选择（即贪心选择）来得到。这是贪心算法可行的第一个基本要素，也是贪心算法与动态规划算法的主要区别。

对于一个具体问题，要确定它是否具有贪心选择性质，必须证明每一步所做的贪心选择最终导致问题的整体最优解。

#### 2.2 最优子结构性质
当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质。问题的最优子结构性质是该问题可用动态规划算法或贪心算法求解的关键特征。

### 3、贪心算法的求解步骤
在设计贪心算法时采用的步骤：

	(1) 决定问题的最优子结构；
	(2) 设计出一个递归解；
	(3) 证明在递归的任一阶段，最优选择之一总是贪心选择。那么，做贪心选择总是安全的；
	(4) 证明通过做贪心选择，所有子问题（除一个以外）都为空；
	(5) 设计出一个实现贪心策略的递归算法；
	(6) 将递归算法转换成迭代算法。

通过以上步骤，可以清楚地发现动态规划是贪心算法的基础。然而，实际在设计信心算法时，我们经常会简化以上步骤：通常直接做出贪心选择来构造子结构，以产生一个待优化解决的子问题；或者，根据贪心选择来构造最优子结构。

所以，更一般地，可以根据以下的步骤来设计贪心算法：

	(1) 将优化问题转化成这样的一个问题，即先做出选择，再解决剩下的一个子问题；
	(2) 证明原问题问题一个最优解是做贪心选择得到的，从而说明贪心选择的安全；
	(3) 说明在做出贪心选择后，剩余的子问题具有这样的一个性质，即如果将子问题的最优解和我们所作的贪心选择联合起来，
		可以得出原问题的一个最优解。

由以上我们可以知道：**`无论如何，在每一个贪心算法的下面，几乎总是会有一个更加复杂的动态规划解。`**

### 4、贪心算法与动态规划算法的不同
在动态规划算法中，每步所做的选择往往依赖于相关子问题的解，因而只有在解出相关子问题后，才能做出选择；而在贪心算法中，仅在当前状态下做出最好选择，即局部最优选择；换句话说，当考虑做何选择时，我们只考虑对当前问题最佳的选择而不考虑子问题的结果。然后再去解做出这个选择后产生的相应的子问题。贪心算法所做的贪心选择可以依赖于已经所做过所有的选择，但决不依赖于将来（或者说有待于）所做的选择，也不依赖于子问题的解。正是由于这种差别，动态规划算法通常以自底向上的方式解各子问题，而贪心算法则通常以自顶向下的方式进行，以迭代的方式做出相继的贪心选择，每做一次贪心选择就将所求问题简化为规模更小的子问题。

以0-1背包问题与（部分）背包问题为例：（部分）背包问题即可以用动态规划算法也可以用贪心算法求解；然而，0-1背包问题只能用动态规划算法求解，不能用贪心算法求解。原因：在0-1背包问题中，当我们在考虑是否要把一件物品加到背包中时，必须对把物品加进去的子问题的解与不把该物品加进去的子问题的解进行比较；由于这种方式形成的问题导致了许多重叠子问题（这是动态规划的一个特点），所以，我们可以用动态规划来解决0-1背包问题。

### 5、贪心算法的理论基础
可以用拟阵来研究贪心算法的理论依据。请参见有关“拟阵”的知识。

### 6、常见的贪心算法问题有
常见的贪心算法问题有：`活动安排`、`最优装载`、`哈夫曼编码`、`单源最短路径`、`最小生成树`、`多机调度等问题`。

### 7、其他

### 8、示例

#### 8.1 （部分）背包问题


## 七、回溯算法

### 1、回溯算法的原理（基本思想）
它在问题的解空间树中，按深度优先策略，从根结点出发搜索解空间树；算法搜索到解空间树的任一结点时，先判断该结点是否回溯。如果肯定不包含，则跳过对以该结点为根的子树的搜索，逐层向其祖先结点回溯；否则，进入该子树，继续按深度优先策略搜索。

回溯法求问题的所有解时，要回溯到根，且根结点的所有子树都已被搜索遍才结束。回溯法求问题的一个解时，只要搜索到问题的一个解就可结束。这种以深度优先方式系统搜索问题解的算法称为回溯法，它适用于解组合数较大的问题。

**对回溯的基本思想的补充说明：**在确定了解空间的组织结构后，回溯法从开始结点（根结点）出发，以深度优先方式搜索整个解空间。这个开始结点成为活结点，同时也成为当前的扩展结点。在当前的扩展结点处，搜索向纵深方向移至一个新结点。这个新结点就成为新的活结点，并成为当前扩展结点。如果在当前的扩展结点处不能再向纵深方向移动，则当前扩展结点就成为死结点。此时，应往回移动（回溯）至最近的一个活结点处，并使这个活结点成为当前的扩展结点。回溯法以这种工作方式递归地在解空间中搜索，直至找到所要求的解或解空间中已无活结点时为止。

### 2、回溯法解题的一般步骤
	(1) 针对所给问题，定义问题的解空间；
	(2) 确定易于搜索的解空间结构；
	(3) 以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。

**两个常用的剪枝函数：**

	(1) 约束函数：在扩展结点处减去不满足约束的子数；
	(2) 限界函数：减去得不到最优解的子树。

#### 2.1 问题的解空间
用回溯法解问题时，应明确定义问题的解空间。问题的解空间至少应包含问题的一个（最优）解。从树根到叶的任一路径表示解空间中的一个元素。

#### 2.2 问题的解空间结构

常用的解空间结构一般有两种：**`子集树`**和**`排列树`**。

##### 2.2.1子集树

**(1)子集树的性质：**

当所给问题是从n个元素的集合S中找出满足某种性质的子集时，相应的解空间树称为子集树。这类子集树通常有2n个叶结点，其结点总个数为2n+1-1。遍历子集树的任何算法均需Ω(2n)的计算时间。

**(2)子集树的结构是一个完全二叉树：**

**(3)用回溯地搜索子集树的一般算法可描述如下：**
```c
void BackTrack(int t)
{
	if (t>n)
		Output(x);
	else
		for(int i=0; i<=1; ++i) {
			x[t] =I;
			if(Constraint(t) && Bound(t))  BackTrack(t+1);
		}
}
```

##### 2.2.2 排列树

**(1)排列树的性质：**

当所给的问题是确定n个元素满足某种性质的排列时，相应的解空间树称为排列树。排列树通常有n!个叶结点。因此，遍历排列树需要Ω(n!)的计算时间。

**(2)排列树的结构是一个完全多叉树（即一般的树结构）：**

**(3)用回溯地搜索排列树的算法框架可描述如下：**
```c
void BackTrack(int t)
{
	if (t>n)
		Output(x);
	else
		for(int i=t; i<=n; ++i){
			Swap(x[t], x[i]);
			if(Constraint(t) && Bound(t))  BackTrack(t+1);
			Swap(x[t], x[i]);
		}
}
```

**说明：**在调用BackTrack(1)执行回溯搜索之前，先将变量数组x初始化为单位排列(1, 2, …, n)。

#### 2.3 用回溯法搜索解空间
在回溯地搜索解空间时，有两种回溯方式：**`递归回溯`**和**`迭代回溯`**。

**`递归回溯`**一般使用递归函数来实现，这种方式有一定的局限性（递归层次太深，将会导致递归失败），且效率不高（原因是函数的递归调用）。

**`迭代回溯`**一般使用循环结构来实现，这种方式可突破递归回溯的局限性，且编译器可以进行一些优化，在效率上一般比递归回溯要高一些。

另外，在用回溯法搜索解空间树时，通常采用两种策略避免无效搜索，提高回溯法的搜索效率。其一是用**`约束函数`**在扩展结点处剪去不满足约束的子树；其二是用**`限界函数`**剪去得不到最优解的子树。这两类函数统称为剪枝函数。

##### 2.3.1递归回溯
回溯法对解空间作深度优先搜索，因此在一般情况下可用递归函数来实现回溯法，如下：
```c
void BackTrack(int t)
{
	if (t >n)
		Output(x);
	else
		for (int i=f(n, t); i<=g(n, t); ++i){
			x[t] = h(i);
			if (Constrain(t) &&Bound(t))
				BackTrack(t+1);
		}
}
```
其中，形式参数t表示递归深度，即当前扩展结点在解空间树中的深度。n用来控制递归深度，当t>n时，算法已搜索到叶结点。此时，由Output(x)记录或输出得到的可行解x。算法BackTrack的for循环中f(n, t)和g(n, t)分别表示在当前扩展结点处未搜索过的子树的起始编号和终止编号。h(i)表示在当前扩展结点处x[t]的第i个可选值。Constraint(t)和Bound(t)表示在当前扩展结点处的约束函数和限界函数。Constraint(t)返回的值为true时，在当前扩展结点处x[1:t]的取值满足问题的约束条件，否则不满足问题的约束条件，可剪去相应的子树。Bound(t)返回的值为true时，在当前扩展结点处x[1:t]的取值未使目标函数越界，还需由BackTrack(t+1)对其相应的子树做进一步搜索。否则，当前扩展结点处x[1:t]的取值使目标函数越界，可剪去相应的子树。执行了算法的for循环后，已搜索遍当前扩展结点的所有未搜索过的子树。BackTrack(t)执行完毕，返回t-1层继续执行，对还没有测试过的x[t-1]的值继续搜索。当t=1时，若已测试完x[1]的所有可选值，外层调用就全部结束。显然，这一搜索过程按深度优先方式进行。调用一次BackTrack(1)即可完成整个回溯搜索过程。

##### 2.3.2迭代回溯
采用树的非递归深度优先遍历算法，也可以将回溯法表示一个非递归的迭代过程，如下：
```c
void IterativeBackTrack(void)
{
	int t=1;
	while (t>0) {
		if (f(n, t) <= g(n, t))
			for (int i=f(n, t); i<=g(n, t);++i){
				x[t] = h(i);
				if (Constraint(t) && Bound(t)){
					if (Solution(t))
						Output(x);
					else
						++t;
				}
			}
		else
			--t;
	}
}
```
在上述迭代回溯算法中，用Solution(t)判断在当前扩展结点处是否已得到问题的可行解。它返回的值为true时，在当前扩展结点处x[1:t]是问题的可行解。此时，由Output(x)记录或输出得到的可行解。它返回的值为false时，在当前扩展结点处x[1:t]只是问题的部分解，还需向纵深方向继续搜索。算法中f(n, t)和g(n, t)分别表示在当前扩展结点处未搜索过的子树的起始编号和终止编号。h(i)表示在当前扩展结点处x[t]的第i个可选值。Constraint(t)和Bound(t)是当前扩展结点处的约束函数和限界函数。Constraint(t)返回的值为true时，在当前扩展结点处x[1:t]的取值满足问题的约束条件，否则不满足问题的约束条件，可剪去相应的子树。Bound(t)返回的值为true时，在当前扩展结点处x[1:t]的取值未使目标函数越界，还需对其相应的子树做进一步搜索。否则，当前扩展结点处x[1:t]的取值已使目标函数越界，可剪去相应的子树。算法的while循环结束后，完成整个回溯搜索过程。

### 3、常见的回溯问题有
常见的回溯算法问题有：`装载`、`批处理作业`、`符号三角形`、`N皇后`、`0-1背包`、`最大团`、`图的N着色`、`旅行售货员`、`圆排列`、`电路板排列`、`连续邮资`等问题。

### 4、其他

（1）回溯法有“**_通用的解题法_**”之称。用它可以系统地搜索一个问题的所有解或任一解。回溯法是一个既带有系统性又带有跳跃性的搜索算法。

（2）用回溯法解题的一个显著特征是在搜索过程中动态产生问题的解空间。在任何时刻，算法只保存从根结点到当前扩展结点的路径。如果解空间树中从根结点到叶结点的最长路径的长度为h(n)，则回溯法所需的计算空间通常为O(h(n))。而显式地存储整个解空间则需要O(2h(n))或O(h(n)!)内存空间。

（3）生成问题状态的基本方法：

**扩展结点**

	一个正在产生儿子的结点称为扩展结点；

**活结点**

	一个自身已生成但其儿子还没有全部生成的节点称做活结点；

**死结点**

	一个所有儿子已经产生的结点称做死结点；

**深度优先的问题状态生成法**

	如果对一个扩展结点R，一旦产生了它的一个儿子C，就把C当做新的扩展结点。
	在完成对子树C（以C为根的子树）的穷尽搜索之后，将R重新变成扩展结点，继续生成R的下一个儿子（如果存在）；

**宽度优先的问题状态生成法**

	在一个扩展结点变成死结点之前，它一直是扩展结点；

**回溯法**

	为了避免生成那些不可能产生最佳解的问题状态，要不断地利用限界函数(bounding function)来处死(剪枝)那些
	实际上不可能产生所需解的活结点，以减少问题的计算量。具有限界函数的深度优先生成法称为回溯法。（回溯法 = 穷举 +　剪枝）。

### 5、示例

#### 5.1 N皇后问题

#### 5.20-1背包问题


## 八、分支限界算法

### 1、分支限界法的原理（基本思想）
分支限界法在它的问题的解空间中，采用广度优先或最小耗费（最大效益）优先的方式搜索解空间树，直至找出满足约束条件的一个解，或是在满足约束条件的解中找出使某一目标函数值达到极大或极小的解，即在某种意义下的最优解。

### 2、问题的解空间结构
问题的解空间树一般有两种：**`子集树`**和**`排列树`**。具体的参见“回溯法”中的2.2节。

### 3、分支限界法与回溯法的不同

#### 3.1 求解目标的不同

	(1) 回溯法的求解目标是找出解空间树中满足约束条件的所有解；
	(2) 分支限界法的求解目标则是找出满足约束条件的一个解，或是在满足约束条件的解中找出在某种意义下的最优解。

#### 3.2 搜索方式的不同
由于求解目标不同，导致了分支限界法和回溯法对解空间的搜索方式也不相同。

	(1) 回溯法以深度优先的方式搜索解空间树；
	(2) 分支限界法则以广度优先或以最小耗费（最大效益）优先的方式搜索解空间树。

#### 3.3 结点扩展方式不同
由于搜索解空间树的方式不同，也就导致了分支限界法和回溯法对当前扩展结点所采用的扩展方式不同。在分支限界法中，每一个活结点只有一次机会成为扩展结点。活结点一旦成为扩展结点，就一次性产生其所有儿子结点。在这些儿子结点中，导致不可行解或导致非最优解的儿子结点被舍弃，其余儿子结点被加入活结点表中。此后，从活结点表中取下一个结点成为当前扩展结点，并重复上述结点扩展过程。这个过程一直持续到所需的解或活结点表为空时为止。

注：在选择扩展结点时，为了有效地选择下一扩展结点，加速搜索的进程，在每一活结点处，计算一个函数值（限界），并根据函数值，从当前活结点表中选择一个最有利的结点作为扩展结点，使搜索朝着解空间上有最优解的分支推进，以便尽快地找出一个最优解。这种方式称为分支限界法。

#### 3.4 存储空间的要求不同
分支限界法的存储空间比回溯法大得多，因此当内存容量有限时，回溯法成功的可能性更大。

### 4、分支限界法的分类
从活结点表中选择下一扩展结点的不同方式导致不同的分支限界法。最常见的有以下两种方式：

#### 4.1 队列式（FIFO）分支限界法
队列式分支限界法将活结点表组织成一个队列，并按队列的先进先出原则选取下一个结点为当前扩展结点。

#### 4.2 优先队列式分支限界法
优先队列式的分支限界法将活结点表组织成一个优先队列，并按优先队列中规定的结点优先级选取优先级最高的下一个结点成为当前扩展结点。

在优先队列中规定的结点级常用一个与该结点相关的数值p来表示。结点优先级的高低与p值的大小相关。最大优先队列规定p值较大的结点优先级较高。在算法实现时通常用最大堆来实现最大优先队列，用最大堆的Deletemax运算抽取堆中下一个结点成为当前扩展结点，体现最大效益优先的原则。类似地，最小优先队列规定p值较小的结点优先级较高。在算法实现时通常用最小堆来实现最小优先队列，用最小堆的Deletemin运算抽取堆中下一个结点成为当前扩展结点，体现最小费用优先的原则。

用优先队列式分支限界法解具体问题时，应根据具体问题的特点确定选用最大优先队列或最小优先队列来表示解空间的活结点表。

### 5、常见的分支限界法问题
常见的分支限界法问题有：`单源最短路径`、`装载`、`布线`、`0-1背包`、`最大团`、`旅行售货员`、`电路板排列`、`批处理作业调度`等问题。

### 6、其他
除了`求解目标`、`搜索解空间方式`、`结点扩展方式`不同外，`分支限界法`和`回溯法`基本相同，其他的问题请参见“回溯法”。

### 7、示例

#### 7.10-1背包问题

#### 7.2 装载问题


## 九、随机化算法


## 十、线性规划


## 十一、网络流


## 十二、NP完全性理论
