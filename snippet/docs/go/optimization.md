# Go 优化

## 前言
一些 Go 语言的核心包、库应该尽可能地进行优化，以提高其性能。当然，对于一些业务逻辑代码，其目标是快速开发，提升效率，而不是将性能发挥到极致，因此，下面一些优化策略仅针对核心包、库，而非业务逻辑代码。这并不是说，业务逻辑代码则可以不优化、随便写；对于业务逻辑代码，只是有选择性地进行优化，其优化要平衡好开发效率与程序性能。

作为一个建议：业务代码的目标是尽快地实现一个业务需求，而不是追求极致的性能；性能优化是在完成业务需求之后进行的，而且性能优化的功能不能改变已实现的业务需求逻辑。


## 优化策略

### 1. 拒绝正则和反射
`正则表达式` 和 `反射` 都有很大的开销，应当尽量避免。在使用这两种技术时，应先考查一下是否还有其它不是很复杂的解决方案。

因此，应尽量避免使用 `正则表达式` 和 `反射`，除非没有其它替代方案或替代方案实现起来比较复杂。


### 2. 使用 `sync.Pool` 重用对象

频繁地分配和释放内存也会频繁地引发 GC 进行垃圾回收，从而对性能造成一定的影响。因此，在追求极致的性能过程中，要尽可能地减少甚至达到内存零分配。而标准库中的 `sync.Pool` 可能重用对象，避免重新分配和释放内存。

**注意**：

`sync.Pool` 也是有开销的：当从 Pool 中得到一个对象，或者把一个对象放入 Pool 中时，`sync.Pool` 都会进行加锁。在大量并发的情况下，`sync.Pool` 中的锁机制有可能会成为阻碍性能提升的瓶颈点。这一点要根据具体的实际情况进行权衡。


### 3. 为 `slice` 预分配内存

`slice` 本质上就是一个长度可变的 `array`，它根据存储的容量会动态地重新分配内存并迁移数据。如果长度不断变化，就会导致不断的重新分配内存，迁移数据。在一定的特定场景下，我们可以为 `slice` 预先分配一定长的内存（预分配的内存应尽量满足 `slice` 的最终需求），以避免 `slice` 自动地重新扩张内存。如：`v1 := make([]byte, 0, 32)`。

作为一个特例，`array` 可以作为 `slice` 的底层内存，如：`Slice := Array[:0]`。


### 4. 重用 `slice`

当一个 `slice` 不再使用，而又有新的变量需要一个 `slice`，可以重用不再使用的 `slice`，这样可以避免旧 `slice` 的释放和新 `slice` 的分配。

作为一个特例，当重置一个 `slice` 时，可以重新利用原先的 `slice`，而不是重新分配一个。如：
```go
v1 := make([]byte, 0, 32)
v1 = v1[:0]  // Reset the slice to the empty.
```


### 5. 使用 `[]byte` 代替 `string`

尽量使用 `[]byte` 类型替代 `string`，因为 `string` 在处理字符串时会有编码和解码的工作，会影响解析字符串的性能。

**注**：当特别需要使用 `string`，可以通过 `string(byte_slice_var)` 的方式临时将 `[]byte` 类型转换成 `string` 类型。


### 6. 使用 `slice` 的 `range` 替代 `map` 的 `range`

目前 `map` 的 `range` 比 `slice` 的 `range` 要低一个数量级，因此，当要频繁地迭代一个 `map` 时，可以考虑使用 `slice` 来代替 `map`。

**注意**：

虽然 `map` 的 `range` 性能相对较差，但查询 `键-值` 对确实相对较高。如果须要频繁地查询与某个键对应的值，还是尽量使用 `map`，而非 `slice`。


### 7. 凡是迭代就都有开销

虽然 `slice` 的迭代比 `map` 快，但迭代总归是迭代，因此，它还是有开销的。当需要进行迭代匹配时，可以借鉴 `map` 的思想（散列、哈希），如：先比较前一个或几个字节，或比较某个关键字段，如果不匹配，即为不匹配，否则，再进行下一步的迭代匹配。


### 8. 尽量避免 `defer`

虽然 `defer` 用起来方便，也仅是用起来方便，但 `defer` 为了保证延迟执行，也是有额外的开销的。因此应尽量避免使用 `defer`。

**例外**：

由于必须使用 `defer` 才能捕获 `panic`，所以这种情况例外——可以使用 `defer`。作为一个约定，尽可能地在必须处理 `panic` 的最后一步才使用 `defer` 去捕获 `panic`。


### 9. 函数调用也有开销

每调用一次函数（哪怕是递归调用），就是产生一个调用栈，因此，调用函数也是有开销的。

作为优化，可以在当前函数中完成的功能，就不要另开一个函数去调用。


## 其它

在优化的过程中，尽可能地使用 `go test -cpuprofile`、`go test -memprofile`、`go test -bench`、`go tool pprof`，它们是最好的性能优化辅助工具。


------

**References:**

- [从Baa开发中总结Go语言性能渐进优化](https://segmentfault.com/a/1190000005690821)
