
GO标准版本变化
===========

# Go1

## 1、多赋值
Go语言支持`多值赋值`，但对于赋值操作符（即等号）左边的变量的计算，是在任何变量被赋值之前被完成，其计算顺序是`从左到右`，一旦计算完，则开始从左到右依次对每个变量进行赋值。如：
```go
sa := []int {1,2,3}
i := 0
i, sa[i] = 1, 2   //  sets i = 1, sa[0] = 2

sb := []int {1,2,3}
j := 0
sb[j], j = 2, 1   // sets sb[0] = 2, j = 1

sc := []int{1,2,3}
sc[0], sc[0] = 1, 2 // sets sc[0]=1, then sc[0]=2 (so sc[0]=2 at end)
```

## 2、相等比较
`struct`和`array`可以进行比较是否相等了，但`函数`和`map`不再支持相等比较了，除了它们`nil`值的比较。

## 3、struct初始化
在初始化`struct对象`时，最好指明`field字段名`，这是向后兼容的，当前也支持直接给初始值，但这并不保证能向后兼容，这个特性也有可能在后续的某个版本中被移除。


# Go1.1

## 1、语言改变
在`GO1`中，整数除以0将导致引发一个运行时“恐慌”（a run-time panic）。

在`GO1.1`中，这将是一个非法程序，是个编译时错误，即在编译时报错，无法通过编译。

## 2、方法值（Method Values）
`GO1.1`实现了`方法值（method values）`，它能绑定到一个指定的接收者上，即可以将一个函数附加到一个`struct`上，从而让此函数成为该`struct`的一个方法。

### 方法值
如果一个表达式X有一个静态类型T，并且M位于类型T方法集中，那么x.M就叫做方法值。
如：
```go
type  T struct {   a  int   }
func (tv  T) Mv(a int) int { return 0}          // value receiver
func (tp *T) Mp(f float32) float32 {return 1}   // pointer receiver
var t T
var pt *T
func makeT()  T
```
### 说明
（1）表达式 `t.Mv` 将产生类型为 `func(int) int` 的函数值。

（2）`t.Mv(7)`` 和 `f:=t.Mv; f(7)`` 是等式价的。

（3）表达式`pt.Mv`将产生类型为 `func(float32) float32` 的函数值。

具体参见语言规范中的“`Method Values`”一节。

## 3、return返回值
在`GO1`中，一个具有返回值的函数必须显示的执行`return`或调用`panic函数`。但在`GO1.1`中，这不必要的。但为保证函数在返回时能有个返回值且可以省略`return`，`GO1.1`引入了一个“`终止语句`”（`terminating statement`）的概念，它是一个能够保证是最后一个函数执行语句的语句。比如：for死循环（死循环一般表示是永不停止，一旦停止表示程序结束，注：这仅一般意义，死循环并不是真正的死循环，比如程序可以跳出死循环）。关于“`终止语句`”的详细信息请参见“`语言规范`”。

总之一句话，_**如果一个函数有返回值，则它必须明确返回一个值，它不像Python语言，如果没有return，默认返回None**_。

## 4、int 和 int32
在`GO1`中，在所有的系统中，`int`和`uint32`都有是`32位`的。但在`GO1.1`中，`int`和`uint32`都有是`64位`的。

## 5、堆大小
在`64位系统`中，相对`GO1`，`GO1.1`的堆大小从`GB`增大到`TB`级；而在`32位系统`中，堆大小并没有改变。

## 6、go get 命令
从`GO1.1`开始，`go get` 命令下载的源码包不再默认放到 `$GOROOT` 环境变量指向的目录中，而使用 `$GOPATH` 所指向的目录列表中的第一个目录中。另外，从`GO1.1`开始，`go` 工具链不再允许 `$GOPATH` 和 `$GOROOT` 设置成相同的值。

## 7、支持系统和平台
相对`GO1`，`GO1.1`支持更多的系统和平台。另外，在`GO1.1`中，`go tool` 默认取消 `cgo` 的支持，但可以设置 `CGO_ENABLED=1` 来显示地启用 `cgo`。

## 8、性能
`Go1.1`比`GO1`有了更大的性能提升，大约在 `30%~40%` 左右；垃圾回收器也已经做到了更大程序上并行处理。

## 9、time 包精度
`Go1`中，`time包`只能达到`微秒精度（microsecond precision）`；而在`GO1.1`中，`time包`能达到`纳秒精度（nanosecond precision）`。


# Go1.2

## 1、nil 指针
为了安全的考虑，从`Go1.2`开始，`nil` 指针的一些使用会被保证触发一个运行时“`恐慌`”（a run-time panic）。如：
```go
type T struct {
    X  [1<<24]byte
    Field  int32
}
func main() {
    var x *T
    ...
}
```
由于 `x` 变量没有初始化值，因此默认初始化为 `nil`。但在`Go1.2`之前，这个 `x` 变量能够以不正确的访问方式来访问内存：表达式 `x.Field` 能够访问地址为 `1<<24` 处的内存。为了阻止这个不安全的行为，在`Go1.2`中，编译器将保证 `nil` 指针的任何间接性的非法操作都将会引发一个“`panic`”或返回一个正确并安全的`non-nil`值。

总之一句话，_**任何显式或隐式地需要计算一个nil地址的表达式都是错误的**_。

## 2、三索引分片
从`GO1.2`开始，允许`三索引分片（Three-index slice）`：可以在分片操作中指定第三个索引，以表明新产生的分片是容量。如：
```go
var array [10]int
slice := array[2:4]
```
上述分片`slice`变量的容量是`8`，即从底层数组的第三个元素（因为数组下标从0开始）开始一直到最后，但是该分片变量`slice`能使用的只有其中的两个，除非使用内建的`append`函数来增加其使用量。

如果想指定分片`slice`的容量，在`GO1.2`中，可以在分片中指定第三个索引，该索引指定终止索引位。如：
```go
slice := array[2:4:7]
```
此时，`slice`的容量将是`5（7-2）`，其容量是`底层数组的第三个到第七个（包含第七个）`，即`底层数组的索引是2~6`，但是同上述一样，默认能使用的也只是2个，要想增加使用量，需要使用内建函数append来追加元素。

三索引的意思：

    第一个索引表示容量或能使用的底层数组的开始索引，
    第二个索引表示默认能使用的终止索引（不包含它，即整体是半开半闭区间），
    第三个索引表示其容量的终止索引（不包含它，即整体是半开半闭区间）。

目前的实现是：

    第一个索引可以省略，如果没有指定，则默认为0，但其他两个必须显示指定，然后将来的实现可以会为其引入一个默认值。
    第三个索引的值必须小于或等于产生新分片的源数组或源分片的容量，
    比如：上述例子中的第三个索引就不能指定为大于10的值，因为该数组的空间最大才是10个元素。

具体细节请参见“`语法规范`”。

## 3、goroutine和线程
在`GO1.2`之前，当通过`GOMAXPROCS`来设定只有一个用户线程时，一个永久循环（或死循环）的`goroutine`会使在同一线程中的其他`goroutine`因资源枯竭（如永远得不到CPU）而“死亡”（并不是真正的死亡、终结，而是因为永远得不到调度，名存实亡）。在`GO1.2`中，这种情况得到了缓解，或者说是部分解决，即GO调度器会偶尔地调度那些“名存实亡”的goroutine，使其“名存实存”。

为了避免在一些环境中导致资源枯竭，`GO1.2`引入了一个可配置的限制（默认是`10000`）来限制一个单独程序在它的地址空间中所能使用的线程总数。由于`goroutine`是`多路复用在线程上`的，所以这个限制并不直接限制`goroutine`的数量，而仅仅是同时被阻塞在一个系统调用上的数量。

## 4、栈大小
在`GO1.2`中，增大了GO例程栈的大小，能够减少栈溢出。

    在32位系统上，默认大小是250M；
    在64位系统上，默认大小是1GB。

## 5、包
`GO1.2`要求在每个包中的每个文件中必须明确通过 `package` 语句指定其包名。

## 6、Go工具链
（1）在`GO1.2`中，`cgo`可以调用C++编译器构造的C++代码链接库了。

（2）在`GCC4.8.2`版本中，`gccgo`只实现到 `Go1.1.2`；有望在 `GCC4.9` 版本中完全支持 `GO1.2`。

（3）在`GO1.2`中，`go get` 命令新增了 `-t` 标志，它在下载一个包时，同时也会下载该包的依赖包。

## 7、Go标准库
（1）在`GO1.2`中，部分标准库包得到了优化，性能提高了将近 `30%` 左右，如：`comress/bzip2`、`crypto/des`、`encoding/json`以及网络通信包。

（2）在`GO1.2`中，标准库包 `fmt` 中的格式化输出例程允许为输出数据指定索引操作，以便以任意的顺序来访问输出数据。如：
```go
fmt.Sprintf("%[3]c %[1]c %c", 'a', 'b', 'c')
```
其结果是 "`c a b`"。

（3）在`Go1.2`中，标准库 `text/template` 和 `html/template` 包新增了一些比较函数，如：`eq`、`ne`、`lt`、`le`、`gt`、`ge`等。

注：这些比较函数和相应的GO操作符不同。

    其一，这些函数只能比较基本类型，如：bool、int、float64、string等等；
    而GO操作符除了能比较基本类型外，还能比较数组和结构体struct。

    其二，只要它们的值有相同的分类（注：所有的整数都是一类的，而不管其表示位数），那么它们就能直接进行比较操作；
    然而，Go操作符却不允许，如：GO不允许int8和int16直接进行比较操作，必须先进行类型转换。

（4）在`Go1.2`中，标准库 `text/template` 和 `html/template` 包也新增了 `{{else if}}`` 语法。如：
```go
{{if  eq  .A  1}}  X  {{else}}  {{if  eq  .A  2}}  Y  {{end}}  {{end}}
```

在`GO1.2`中，可以简写成：
```go
{{if  eq  .A  1}}  X  {{else  if  eq  .A  2}}  Y  {{end}}
```
二者是等效的，仅仅是语法不同罢了。


# Go1.3

## 1、总体变化
在语言规范没有作任何改变。此版本的改变主要聚焦在实现上，如更加精确的垃圾回收机制、编译工具链的重构（以提高构建速度）、性能的提升以及更多平台的支持。在兼容性上，与之前的版本完全兼容。

## 2、内存模型变化
主要增加了一条新的规则，此规则会影响到缓冲区管道（Buffered Channels）的发送和接收。

## 3、栈（Stack）
Goroutine Stack的实现由段（Segmented）模型改变成邻近（Contiguous）模型。

## 4、垃圾回收器
从Go1.3开始，运行时假定指针类型的值包含指针，而其它类型的值则不会。因此，使用 `unsafe` 包在一个指针类型变量中存储整数为非法操作；如果运行时侦测到此行为，程序将会崩溃。同样的，使用 `unsafe` 包在一个整数类型变量中存储指针也为非法操作，但是，此行为在执行期间很难被诊断。

与以前代码不兼容的之处：不能使用 `unsafe.Pointer`，将一个整型类型变量转换成一个指针，否则，将产生一个非法操作。

## 5、Map迭代
此版本之前，Go规范规定，不大于8个元素的小Map在迭代时，其迭代顺序是有序的，但对于大Map，是无序的。
从Go1.3开始，小Map上的迭代也不再有序，而是随机的。

**备注：**

Go 1 标准规范规定：_**在Map上的迭代是无序的，前后两次的迭代顺序并不保证一致**_。
直到 Go 1.3 才真正实现了这一规范。


# Go1.4

## 1、For-range Loop
新增一种格式：
```go
for expr1 = range expr2 {  statements }
```
具体见上面For语句。

## 2、`**T` 的方法调用
Go规范不再允许双引用，而只允许单引用。

## 3、运行时
（1）大部分代码用Go语言重写，并且有更高的精度和消耗更小的堆空间。

（2）栈完全取消段模型。

（3）修改了 interface 的实现。


# Go1.5

## Map字面值
从 Go 1.5 开始，Map字面值中元素的类型可以被省略。如：
```go
// Before 1.5
m := map[Point]string{
    Point{29.935523, 52.891566}:   "Persepolis",
    Point{-25.352594, 131.034361}: "Uluru",
    Point{37.422455, -122.084306}: "Googleplex",
}

// Since 1.5
m := map[Point]string{
    {29.935523, 52.891566}:   "Persepolis",
    {-25.352594, 131.034361}: "Uluru",
    {37.422455, -122.084306}: "Googleplex",
}
```

## 开发实现
（1）除了额外的一小部分汇编外，编译器完全用 Go 重写。

（2）GC是并发的，并且在执行GC时，减少了整个程序的暂停时间：被限制在 10ms 以内，有时会更少。

（3）默认地，GOMACPROCS被设置到可见到的CPU核数。先前版本被默认设置到 1。

（4）Go 工具链开始试验性地支持包的版本依赖。

## 移植性
一些老的平台和系统版本不再支持。

## 工具链
（1）新增 `go tool trace` 命令，可进行细粒度地追踪程序的执行。

（2）新增 `go doc` 命令（与 `godoc` 不同）。

（3）编译器（`6g`、`8g`等）、汇编器（`6a`、`8a`等）和链接器（`6l`、`8l`等）被废弃，分别内建到 `go tool` 工具链中（`go tool compile`、`go tool asm`、`go tool link`）。如：
```shell
$ export GOOS=darwin GOARCH=amd64
$ go tool compile program.go
$ go tool link program.o
```

