
表达式
=====

## 1、内建函数new
表达式`new(T)`分配一个零初始化的值，并返回指向它的指针。如：
```go
var t *T = new(T)
```
或
```go
t := new(T)
```


## 2、操作符
GO中只有 `一元操作符` 和 `二元操作符`，没有`三元操作符`。

一元操作符：`+    -    !    ^    *    &    <-`

二元操作符：`||   &&   ==   !=   <    <=   >   >=   +   -   *   /   %   |   ^   >>   <<   &   &^`

注：像`+`、`-`、`*`、`^`、`&`均可以作为`一元操作符`或`二元操作符`，但其具有不同的含义。


## 3、操作符优先级
（1）**`一元操作符有最高的优先级`**；但是 `++`` 和 `--`` 操作符不再操作符优先级之内，因为它们是语句，而不表达式。

如：`*p++`` 等价于 `(*p)++`，并且此语法是个语句，并不是表达式，因为不能用在其他语句之内。

（2）**`二元操作符有五个优先级等级`**，从高到低，依次是：`乘法（Multiplication）`、`加法（Addition）`、`比较（Comparison）`、`逻辑与&&（logical AND）`、`逻辑或||（logical OR）`。如下表：
```go
    Precedence              Operator
        5                     *    /    %    <<   >>   &   &^
        4                     +    -    |    ^
        3                     ==   !=   <    <=   >    >=
        2                     &&
        1                     ||
```
注：当二元操作符有相同的优先级时，则按 `从左到右` 的顺序进行结合。


## 4、计算顺序
当需要计算一个表达式的操作数时，`赋值语句`、`return语句`、`所有的函数调用`、`方法调用` 以及 `通信操作`（如channel管道）都将会按照 `从左到右` 的顺序依次计算。如：
```go
y[f()], ok = g(h(), i()+x[j()], <-c), k()
```
注：
（1）函数调用和通信操作的执行顺序依次是：`f()`、`h()`、`i()`、`j()`、`<-c`、`g()`、`k()`。但是对于 `x` 的索引 和 `y` 的计算的顺序并没有作出规定。

（2）最佳实践一般不会写出这样的代码（计算顺序不确定）；如果确实需要这样的代码，应该将其拆句几个语句。


## 5、类型推断表达式
（1）“`类型推断`”可将一个`interface类型`的`变量x`转换成`T类型`的变量。

（2）“`类型推断表达式`”有两个要求：

    A. 变量x必须是非 nil 值的interface变量；
    B. 变量x中存储的是T类型的值。

（3）在“`类型推断`”中，`类型T` 即可以是`interface`，也可以是`非interface类型`。准确地说，

    A. 如果 类型T 不是 interface类型，那么 x.(T)将认定 x 的动态类型标识化T类型，即 x 的 动态类型 和 T类型 有完全相同的标识化。
       在这种情况下，类型T 必须实现 x 的 interface类型，否则这个类型推断是无效的，因为x不能存储 类型T 的值。
    B. 如果类型T 是interface类型，那么x.(T) 将认定 x 的动态类型实现了 interface类型T。

注：关于`类型标识化（Type Identical）`，请参见上文的“类型标识”。

（4）如果类型推断有效，那么其表达式的值就是存储在 `x` 中的值，而且其类型是`T类型`；否则，运行时`panic`将会发生。

（5）类型推断表达式可以用于赋值或初始化中，其格式如下：
```go
v, ok = x.(T)
v, ok := x.(T)
var v, ok = x.(T)
```
其中，`ok` 是一个`boolean`值，如果推断成功，`ok` 为 `true`；否则，则 `ok` 为`false`，并且 `v` 的值是`类型T`的`零值`。


## 6、索引表达式
（1）索引表达式的格式：`a[x]`

其中，`a`是`数组Array`、`指向数组的指针Pointer`、`分片Slice`、`字符串String` 或 `映射Map`，`x`是`索引`；根据 `a` 的类型的不同，`x`分别叫做 `索引Index` 或 `键Key`。

（2）如果 a 不是 `Map`：

    A. 索引 x 必须是整数类型或untyped的整数字面值；并且它的值必须满足 0 <= x < len(a)，否则它是超出值域，将会抛出Panic。
    B. 常量索引值必须是非负整数，并且可以表示为 int类型的值。

（3）如果 a 的类型是 `Array类型A`：

    A. 常量索引必须位于值域内，即 0 <= x < len(a)，否则将发生运行Panic。
    B. a[x] 的值是索引x 处的数组a的元素，其类型是元素类型A。

（4）如果 a 的类型是`指向Array的Pointer类型`：

    A. a[x] 是 (*a)[x] 的简化，即简短表示，二者是等价的。

（5）如果 a 的类型是 `Slice类型S`：

    A. a[x] 的值是索引x 处的分片a 的元素，其类型是元素类型S。

（6）如果 a 的类型是 `String类型S`：

    A. a[x] 的值是索引x处的非常量（non-constant）字节，其类型是byte。
    B. a[x] 不能被赋值，因为string是只读的。

（7）如果 a 的类型是 `Map类型M`（假设Key的类型为K，Value的类型为V）：

    A. x 的类型必须可确定为类型K。
    B. 如果映射中包含一个键为x的一个键值对，那么 a[x] 就是键为x的 map 值，且其类型就是类型V。
    C. 如果映射为 nil 或没有包含键为 x 的键值对，那么 a[x] 的值就是类型V的零值。

（8）其它任何情况，`a[x]` 都是`非法的`、`无效的`。

（9）一个 `map[K]V` 类型的索引表达式可以用于`赋值`或`初始化`中，格式如下：
```go
v, ok = a[x]
v, ok := a[x]
var v, ok = a[x]
```
其中，`ok` 是一个`boolean`值，如果`a`中存在键为`x`的键值对，则 `ok` 为 `true`；否则，`ok` 为`false`，并且 `v` 的值是`类型T`的`零值`。

（10）如果给一个值为 `nil` 的 `Map` 变量添加键值对，将引发运行时`Panic`。 但是`获取是可以的`，`其值为相应类型的零值`。
