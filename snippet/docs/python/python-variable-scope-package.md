
六、变量名、对象、作用域及命名空间（模块）的分析
========================================

## （一）变量名与对象
1、Python自称是完全面向对象编程语言，即所有的东西都是对象，包括其他常见编程语言（如C++、Java、C#等）中的对象、类对象以及函数、类本身等等。此时，在学习Python时会对初学者造成一定的误解，这是因为Python使用者并不直接使用这些对象，而是通过一个变量名。

2、在其他常见的编程语言（如C++），变量名代表着（或者说绑定到）一个地址空间，而且一旦绑定，以后是不能改变的，所以，如果我们把这个地址空间称为一个“对象”的话，那么这个变量名就直接可以称为“对象“了。但是，在Python中，变量名却有着不定的含义。在Python中，对象相当于C++中的变量或类对象，是可以直接操作数据存储的，但这个对象是封装在底层的，为了方便使用者使用，所以就使用一个名字，这个名字可以引用任意的对象，而这个名字就是变量名。在这，我们要明白一点，变量名是可以随意改变的，即可以在任何时候、随意地指向任何对象，例如：如果变量A指向一个整数对象B，然后可以改变 A使它再次指向字符串对象C，此时对A的操作只作用于它所指向的字符串对象C，而对整数对象B不会产生任何影响。

举个例子：
```python
A = 123
A = "abc"
```
在Python执行第一个语句时，Python会先通过整数类型构造函数创建一个整数对象（如果该对象不存在的话），并把它的值赋值为123，最后，用变量名A来指向这个整数对象。当执行第二条语句时，Python会先通过字符串类型构造函数创建一个字符串对象（如果该对象不存在的话），并把它的值赋值为"abc"，最后，用变量名A来指向这个字符串对象，而以前的整数对象（其值为123）就不能再通过变量名A来引用了。

3、通过上例，我们可以发现一个问题，对于某些可变对象或者一些其他情况，如果我们要改变它本身的值并且原变量名仍然指向该变量时，不能简单的使用等号 （=）操作符；这种情况尤其是通过from进行模块导入时，最让人容易忽略它的弊端。要想真正地解决原问题，可以直接引用原底层对象；这并没有违背我们上面所说，其中的一个原理可以参见类对象属性的添加。

4、在此，我们说明一点：虽然Python把所有的对象封装到底层，并通过一个名字来引用，但是，当操作这个名字时的任何动作都会作用到它所指向的对象，就像我们在直接操作底层对象一样。变量名没有类型，你可以把简单地理解成C/C++中的宏定义。因此，我们可以看出，变量名并没有什么实际意义。


## （二）作用域与命名空间
### 1、Python中的变量名解析机制：`LE(N)GB`法则
（1）当在函数中使用未认证的变量名时，Python会依次搜索4个作用域[`本地作用域（L）`，之后是`上一层结构中def或lambda的本地作用域（E）`，之后是`全局作用域（G）`，最后是`内置作用域（B）`]，并且在第一处能够找到这个变量名的地方停下来。如果变量名在这次搜索中没有找到，Python就会报错。

（2）**`当在函数中给一个变量名赋值时（而不是在一个表达式中对其进行引用），Python总是创建或改变本地作用域中的变量名，除非它已经明确地在那个函数中声明为全局变量（global）或非局部变量（nonlocal）以改变其属性。`**

（3）当在函数之外给一个变量名赋值时（也就是，在一个模块文件的顶层，或者是交互提示模式下），本地作用域与全局作用域（这个模块的命名空间）是相同的。

（4）所有其他的变量名都可以归纳为本地、全局或者内置的。

### 2、作用域嵌套
作用域可以做任意的嵌套（也就是说，函数可以任意层次地嵌套），但是只有内嵌的函数（而不是类）会被搜索。

### 3、nonlocal
**`nonlocal应用于一个嵌套的函数的作用域中的一个名称，而不是所有def之外的全局模块作用域；而且在声明nonlocal名称的时候，它必须已经存在于该嵌套函数的作用域中——它们可能只存在于一个嵌套的函数中，并且不能由一个嵌套的def中的第一次赋值创建。换句话说，nonlocal即允许对嵌套的函数作用域的名称赋值，并且把这样的名称的作用域查找限制在嵌套在def中。`**

nonlocal使得对语句中列出的名称的查找从嵌套的def的作用域中开始，而不是从声明变量的本地作用域开始，也就是说，nonlocal也意味着“完全略过我的本地作用域”。实际上，**`当执行到nonlocal语句时，nonlocal中列出的名称必须在一个嵌套的def中提前定义过；否则，将会产生一个错误`**。

### 4、global与nonlocal的区别
（1）`global使得作用域查找从嵌套的模块的作用域开始，并且允许对那里的名称赋值`。如果名称不存在于该模块中，作用域查找继续到内置作用域；但是，对全局名称的赋值总是在模块的作用域中创建或修改它们。

（2）`nonlocal限制作用域查找只是嵌套的def，要求名称已经存在于那里，并且允许对它们赋值`。作用域查找不会继续到全局或内置作用域。

### 5、全局作用域
全局作用域的作用范围仅限于单个文件。在Python中没有基于一个单个的、无所不包的情景文件的全局作用域的。

### 6、变量赋值
**`赋值的变量名除非被声明为全局变量或非本地变量，否则均为本地变量`**。在默认情况下，所有函数定义内部的变量名是位于本地作用域（与函数调用相关的）内的。如果需要给一个在函数内部都位于模块文件顶层的变量名赋值，需要在函数内部通过global语句声明；在没有声明global的情况下，只能引用变量，而不能对变量进行赋值。如果需要给位于一个嵌套的def中的名称赋值， 从Python3.0开始可以通过在一条nonlocal语句中声明它来做到。`任何情况下，一个变量的作用域（它所使用的地方）总是由在代码中被赋值的地方所决定，并且与函数调用完全没有关系。`

### 7、各种赋值与引用的总结
#### （1）无点号的简单变量名遵循函数LEGB作用域法则
##### 赋值语句（X=Value）
    使变量名成为本地变量——在当前作用域内创建或改变变量名X，除非声明它是全局变量。

##### 引用（X）
    在当前作用域内搜索变量名X，之后是在任何以及所有的嵌套的函数中，然后是在当前的全局作用域中搜索，最后在内置作用域中搜索。

#### （2）点号的属性名指的是特定对象的属性，并且遵循模块和类的规则
##### 赋值语句（object.X=value）
    在进行点号运算的对象的命名空间内创建或修改属性名X，并没有其他作用。继承树的搜索只发生在属性引用时，而不是属性的赋值运算时。

##### 引用（object.X）
    就基于类的对象而言，会在对象内搜索属性名X，然后是其上所有可读取的类（使用继承搜索流程）。
    对于不是基于类的对象而言（例如：模块），则是从对象中直接读取X。

### 8、命名空间
（1）当在一个程序中使用变量名时，Python创建、改变或查找变量名都是在所谓的命名空间（一个保存变量名的地方）中进行的。

（2）在代码中给一个变量赋值的地方决定了这个变量将存在于哪个命名空间，也就是它可见的范围。

（3）除打包代码之外，函数还为程序增加了一个额外的命名空间层：在默认情况下，一个函数的所有变量名都是与函数的命名空间相关联的。这意味着：

    A. 一个在def内定义的变量名能够被def内的代码使用，不能在函数的外部引用这样的变量名；
    B. def之内的变量名与def之外的变量名并不冲突，即使是使用在别处的相同的变量名。

##（三）模块、包的导入
1、一个模块文件的全局变量一旦被导入就成为了这个模块对象的一个属性：导入者自动得到了这个被导入的模块文件的所有全局变量的访问权。所以，在一个文件被导入后，它的全局作用域实际上就构成了一个对象的属性。

2、**导入只发生一次。**

（1）当一个模块被导入时，Python会把内部模块名映射到外部文件名，也就是通过把模块搜索路径中的目录路径加在前边，而`.py`或其他后缀名添加在后边。

（2）`import`会读取整个模块，所以必须进行定义后才能读取它的变量名；`from`将获取（或者说是复制）模块特定的变量名。

（3）人技术角度来说，`import`和`from`语句都会使用相同的导入操作。`from *`形式只是多加个步骤，把模块中所有变量名复制到了进行导入的作用域之内。从根本上说，就是把一个模块的命名空间融入另一个模块之中；同样地，实际效果就是可以让我们少输入一些。

（4）`import`和`from`都是隐性的赋值语句。`import`将整个模块对象赋值给一个变量名；`from`将一个或多个变量名赋值给另一个模块中同名的对象。

（5）以`from`复制而来的变量名和其来源的文件之间并没有联系。为了实际修改另一个文件中的全局变量名，必须使用`import`。

（6）`from`只是把变量名从一个模块复制到另一个模块，并不会对模块名本身进行赋值。从概念上来说，以下两种语句等效：
```python
from module import name1, name2
```
等价于：
```python
import module
name1 = module.name1
name2 = module.name2
del module
```

（7）`from`语句有破坏命名空间的潜质，理论上是这样的，简单模块一般倾向于使用`import`，而不是`from`。

（8）当你必须使用两个不同模块定义的相同变量名的变量时，才真的必须使用`import`，这种情况下不能使用`from`。

3、**`from`复制、引用变量名，而不是连接**。`from语句其实是在导入者的作用域内对变量名的赋值语句，也就是变量名拷贝运算，而不是变量名的别名机制`。它的实现和Python所有赋值运算都一样，但是其微妙之处在于，共享对象的代码存在于不同的文件中。

4、`模块就是命名空间（变量名建立所在的场所），而存在于模块之内的顶层的变量名就是模块对象的属性`。

5、模块语句会在首次导入时进行。**`在系统中，模块在第一次导入时，无论在什么地方，Python都会建立空的模块对象，并逐一执行该模块文件内的语句，依照文件从头到尾的顺序；而所有的赋值语句都会建立本模块的属性。`**

6、在Python2.6中，包的代码中的常规导入（没有前面的点号），且前默认为一种先相对再绝对的搜索路径顺序，也就是说，它们首先搜索包自己的路径。然而，在Python3.0中，在一个包中导入默认是绝对的——在缺少任何特殊的点语法的时候，导入忽略了包含自身并在sys.path搜索路径上的某处查找。

7、相对导入的作用域

    (1) 相对导入只适用于在包内导入
    (2) 相对导入只是用于from语句

相对导入从2.7版本开始被内置到Python语言当中；在低于2.7的版本中，可以使用`from __future__ import absolute_import`语句来开启它，但是语句在主模块（名为__main__的模块）中无效，只有在非主模块中才有效。

8、使用包含导入和相对导入，Python3.0中的模块查找可以完整地概括为如下几条：

    (1) 简单模块（如A）通过搜索sys.path路径列表上的每个目录来查找，从左到右进行。这个列表由系统默认设置和用户配置设置组成。
    (2) 包是带有一个特殊的__init__.py文件的Python模块的直接目录，这使得一个导入中可以使用A.B.C目录路径语法。
        在A.B.C的一条导入中，名为A的目录位于sys.path的常规搜索目录，B是A中的另一个包子目录，C是一个模块或B中的其他可导入项。
    (3) 在一个包文件中，常规的import语句使用和其他地方的导入一样的sys.path搜索规则。
        包中的导入使用from语句以及前面的点号，然而，它是相对包的；也就是说，只检查包目录，并且不使用常规的sys.path查找。
        例如，在 from . import A 中，模块搜索限制在包含了该语句中的出现的文件的目录之中。
    (4) 相对导入只能用在from子语句中。

9、导入操作不会赋予被导入文件中的代码对上层代码的可见度：被导入文件无法看见进行导入的文件内的变量名。

10、`reload`不会影响`from`导入；递归形式的`from`导入无法工作。

11、每个模块都有一个名为`__name__`的内置属性，Python会自动设置该属性：

    (1) 如果文件是以顶层程序文件执行的，在启动时，__name__就会设置为字符串"__main__"。
    (2) 如果文件被导入，__name__就会成为设成客户端所了解的模块名。

12、包导入

（1）**`当我们使用 from package import item 语法时，item要么是个包package的子模块（或子包），要么是在包package中定义的其他名字`**，如：函数、类或变量。`import语句首先测试item是否已经在包package中定义，如果还没有，它假定它是一个模块并试图导入它；如果找不到这个模块，一个ImportError异常将被抛出。`

（2）相应地，当使用像 `import item.subitem.subsubitem` 语法时，除了最后一个item外，每个item都必须是一个包。最后一个item可以是一个模块或者一个包，但不能是一个在前一个item中定义的类、函数或变量；另外，要想引用它，还必须通过它的全名，如：“`item.subitem.subitem.attribution`”。

（3）当使用语法“`from package import *`”时，如果在一个包中的`__init__.py`文件中定义了一个名为`__all__`的列表，那么只有该列表中列出的名字才能被导入；如果`__all__`没有被定义，语句“`from package import *`”并不从包packae中导入所有的子模块到当前命名空间，它只保证包package已经被导入（可能运行`__init__.py`中的任何初始化代 码），并且导入所有在该包package中被定义的名字（这包括任何被`__init__.py`定义的名字，也包括被上一个import语句显示导入的包的任何子模块）。

13、**“`from item import *`”语句只能出现在模块水平级，而不能出现在class定义和函数定义中。**

注：笔者在Python 2.7和3.1版本中测试了一下，发现“`from item import *`”和“`import item`”语句可以出现在函数和类中的方法中，但不能在class的属性级（即和类的属性在同一缩进水平级）。

14、future语句

（1）Python支持 future 特性，用于支持future特性的Python版本能够使用将来版本的语法特性，以便与将来版本进行兼容。

（2）future语句使用的“`from __future__ import ...`”语法。future语句开启的语法特性都定义在`__future__`模块中；future语法特性从Python2.1版本开始使用，从2.6版本开始支持语法特性有`unicode_literals`、`print_function`、`absolute_import`、`division`、`generators`、`nested_scopes`和`with_statement`等，这些特性从Python3.0版本开始全部默认开启。

（3）future语句只能出现模块的顶层，并且在future语句前只能出现“`模块docstring`”、“`注释`”、“`空白行`”、“`其他的future语句`”。
