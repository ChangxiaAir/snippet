
四、函数
======

## （一）函数的定义
```pytnon
[ decorators ] def funcname([id, id=value, *id, **id]) [ -> expr ] : suite
```
其中，`id`又可写成 `id: expr`，这是对参数的一个注解。

函数定义并不执行函数主体，而是定义一个函数对象，并把该对象绑定到函数名上；只有当调用函数时，才执行函数的主体。

注：参数注解和返回值注解仅 `Python3` 支持，`Python2` 是不支持的。

## （二）函数的参数
在定义一个函数时，其参数的顺序依次（按参数分类）是：

    位置参数（如id）、关键字参数（可以理解为“默认位置参数”，如id=value）、位置参数打包参数（如*id）、关键字参数打包参数（如**id）

该顺序不能颠倒，但是其中某种类型的参数可以省略。
如：
```python
def display(a, b, c=33, d=44, *args, **kwargs):   # 不能写成 def display(a, b, c=33, *args, d=44, **kwargs)
    print  a, b, c, d, args, kwargs
```

## （三）函数的返回值
函数可以返回任意类型的任意值，但是在定义函数时不需要显示声明其返回值的类型，因为Python是弱类型编程语言。如果没有返回一个值，则Python为该函数返回一个`None`值。

## （四）函数的调用
在函数调用时，其参数（按参数分类）的传递顺序是：

    位置参数、关键字参数（这个地方有时候也称为“默认位置参数”）、位置参数解包参数、关键字参数、关键字打包参数

即：
```python
func(id, id=value, *args, id=value, **kwargs)
```
如：
```python
def display(*args, **kwargs):
    print args, kwargs
display(111, 222, c=333, *{555, 666}, d=444, **{'e': 777, 'f': 888})
# 将输出  (111, 222, 666, 555) {'a': 333, 'c': 777, 'b': 444, 'd': 888}
```

在传递参数时，要注意避免

    (1) 一个参数传递多个值，
    (2) 没有为某个位置参数传值。这都将会产生一个TypeError异常。

Python内部是使用以下的步骤来在赋值前进行参数匹配的：

    (1) 通过位置分配非关键字参数
    (2) 通过匹配变量名分配关键字参数
    (3) 其他额外的非关键字参数分配到*args元组中
    (4) 其他额外的关键字参数分配到**args字典中
    (5) 用默认值分配给在头部未得到分配的参数

在这之后，Python检测来确保每个参数只传入了一个值。如果不是这样的话，将会发生错误。当所有的匹配都完成了，Python把传递给参数名的对象赋值给它们。

## （五）函数的深入理解
1、Python中的`def`语句实际上是一个可执行的语句：当它运行时，它创建一个新的函数对象并将其赋值给一个变量名。因为`def`是一个语句，所以它可以出现在任何一个语句可以出现的地方——甚至是嵌套在其他的语句中。在执行`def`语句时，并不会执行函数中的实际代码，它只是创建一个函数对象；只有当通过变量名进行函数调用时，才实际执行函数主体中的代码。因为函数内的变量名在函数实际执行前都不会解析，通常可以利用文件内任意地方的变量。另外，由上我们可以看出，在执行`def`语句时，隐含着执行了一个赋值操作，因此，我们也可以认为`def`语句是一个赋值语句。

2、所有的在函数内部进行赋值的变量名都默认为本地变量；所有的本地变量都会在函数调用时出现，并在函数退出时消失。每次对函数的调用都创建了一个新的本地作用域。也就是说，将会存在由那个函数创建的变量的命名空间。

3、本地变量是静态检测的。在函数中，不可能同时使用同一个简单变量名的本地变量名和全局变量名。如果希望打印全局变量，并在之后设置一个相同变量名的本地变量，可以导入上层的模块，并使用模块的属性标记来获得全局变量。

4、无法从def语句外读取函数或方法内的局部变量。局部变量对于在def内的其余代码才是可见的。而事实上，也只有函数调用或方法执行时，才会存在于内存中。

5、Python中的参数传递机制与C语言中的参数传递机制类似：

    (1) 不可变对象参数通过“值”进行传递（C语言中的“值传递”）
    (2) 可变对象参数是通过“指针”进行传递的（C语言中“地址传递”）
    (3) 无论是不可变对象还是可变对象，Python的参数传递都是把对象赋值给变量名
        (C语言中“地址传递”本质上还是“值”传递，只不过能够修改原实参的值而已)

6、参数的传递是通过自动将对象赋值给本地变量名来实现的。因为引用是以指针的形式实现的，所有的参数实际上都是通过指针进行传递的，但我们不能对该指针进行反解（即直接使用该指针所代表的地址空间）。因此，这就带来了一个结果，我们无法使用Python像C/C++那样编写一个swap函数，用来交换两个参数的值，换句话说，这在Python中是无法实现的。

7、在函数内部的参数名的赋值不会影响调用者。在函数运行时，在函数头部的参数名是一个新的、本地的变量名，这个变量名是在函数的本地作用域内的。

8、改变函数的可变对象参数的值也许会对调用者有影响。

9、**`默认参数是在def语句运行时评估保存的，而不是在这个函数调用时，换句话说，就是函数的默认参数只在定义时计算一次，在调用时不再计算`**。从内部来讲，Python会将每一个默认参数保存成一个对象，附加在这个函数本身。所以，**`如果默认参数是一个可变对象的话，那么该函数的所有调用都共享这个可变对象`**。如果默认参数是可变对象，为了使该函数的每次调用时，该可变对象都互不相关，有一个技术可以实现：把该默认参数写None对象，然后在调用时检查该默认参数是否是None，如果是就自动建立一个局部该类型的可变对象；如果不是None，则说明函数调用没有使用默认参数，所以就可以直接使用它了。

10、C++、Java可以通过定义具有不同参数个数的多个具有相同函数名的函数对象来实现函数重载，但这对Python却不行；在Python中，后一个定义会覆盖前一个定义，因此，最终只有一个定义。

11、在文件间进行通信的最好办法就是通过调用函数，传递参数，然后得到其返回值。
