
## 一、基本知识
### 1、Python命名惯例
(1) 以单一下划线开头的变量名（`_X`）不会被`from module import *`语句导入，一般用于模块或类的内部变量——不被外部所使用；

(2) 前后有双下划线的变量名（`__X__`）是系统定义的变量名，对解释器有特殊意义，这个一般由Python语言来定义（Python魔方）；

(3) 以两个下划线开头，但结尾没有下划线的变量名（`__X`）是类的本地变量（也称私有变量，外部访问时，会被类改写——见下文）；

(4) 通过交互模式运行时，只有单个下划线的变量名（`_`）会保存最后表达式的结果。

说明：私有名压缩只发生在`class`语句中，而且只针对开头有两个下划线的变量名；而且，每个开头有两个下划线的变量名都会发生这种事情，包括方法名称和实例属性名称。类的私有属性名压缩规则：在该属性名前添加一个下划线和类名，如：类Foo中有个__private属性，则压缩后的属性名是_Foo__private。上述“压缩”一词是摘自《Python学习手册（第四版）》一书，但笔者感觉该词用的不妥：我们认为的“压缩”一般指的是多变少、长变短、大变小，而此处的意思却是少变多、短变长。其实“压缩”换成“变换”、“转换”、“转变”或“转化”等词会更好些。

注：以下是Python之父 `Guido` 建议的`命名规范`。

        Type               |       Public        |    Internal
---------------------------|---------------------|------------------
Packages                   | lower_with_under    |
Modules                    | lower_with_under    | _lower_with_under
Classes                    | CapWords            | _CapWords
Exceptions                 | CapWords            |
Functions                  | CapWords            |
Global/Class Constants     | CAPS_WITH_UNDER     | _CAPS_WITH_UNDER
Global/Class Variables     | lower_with_under    | _lower_with_under
Instance Variables         | lower_with_under    | _lower_with_under(protected) or __lower_with_under(private)
Method Names               | lower_with_under()  | _lower_with_under()(protected) or __lower_with_under()(private)
Function/Method Parameters | lower_with_under    |
Local Variables            | lower_with_under    |

### 2、在Python中，变量名没有类型。类型属于对象，而不是变量名；变量名只是引用对象而已。
注：在Python中，所有的东西都是对象，即完全面向对象（像C++，只能算是半完全面向对象——C++中的内建类型并不是我们所谓的“对象”）。但是Python中的变量有点特殊，其实不应该称为变量，应该称为“标签”或“标识”才对（Python官方文档中好像称为“`Name`”）；在Python中，有个“`binding`”概念，它的意思是把“Name”绑定（“binding”）到一个对象——这个对象是在底层的，并不对用户可见，但用户可以通过绑定到底层对象的“name”来引用、使用它，具体请参见下面的“变量名与对象”。

### 3、Python中所有的语句都是实时运行的，没有像独立的编译时间这样的流程——这是解析型编程语言的特征之一。
**辩解：**

有网友对此句提出质疑——Python中的语句是先经过编译成中间字节码然后再运行的，不是实时运行的。对此笔者作出说明：这句原话不是笔者说的，好像是Python大师Mark Lutz在《Python学习手册（第四版）》中说的，如果笔者没有记错的话。笔者在此大言不惭，替Mark Lutz大师作一辩解：编程语言可以分为两人大部类：编译型和解析型（又称“解释型”）。解析型语言有两大实现方案：一是先编译中间字节码，然后把中间字节码放到虚拟机中运行，如Java、Python等；二是直接把源代码放到解析器中解析运行，如shell脚本语言。在判断现代编程语言到底是否编译型还是解析型时，判断依据标准不同，其结果也不同。对于C/C++而言，无用质疑是编译型；但对于其他某些语言，就很难说了。笔者见到几本Java书籍中，以及网上某些文章，都称Java是编译型，在刚开始接触Java时，笔者对这些说法很不愤。编译型的概念无用质疑，但到底什么是解析型语言，有待探讨。分析Java的执行过程：Java首先把Java源代码翻译成中间字节码，然后把字节码放到Java虚拟机中运行，得出结果。反观被所有人一致认为是解析型的Python、Ruby等：它们也是先把源代码（如Python源代码）翻译成中间字节码，然后把中间字节码放到虚拟机中运行，得出结果。换句话，Python等解析型语言的执行方式和Java一样，但为什么Java被认为是编译型的，而Python等反被认为是解析型的呢？究其原因，笔者认为，Java太低等、“愚昧”了，而Python等语言太高等、智能化了——Java源代码在翻译成中间字节码是要求使用者明确地使用javac将其翻译成中间字节码的，然后用java运行的，换句话，java解析程序无法自动调用javac将Java源代码翻译成中间字节码来运行，反观Python等，Python解析器如果发现Python源代码没有对应的中间字节码文件或者中间字节码文件比源代码文件要旧，那么Python解析器会自动（重新）将Python源代码翻译成中间字节码，然后运行它。有人会认为在使用Eclipse等IDE时，直接点击“运行”按钮即可，但是要明白，在点击运行按钮后，IDE工具自动帮忙来完成以上过程了，其实它还是免不了以上过程。由此可见，将Java源代码翻译成中间字节码是单独拿出来，要求明确进行这一步，这就好像要运行C/C++等程序，必须用GCC等编译把C/C++源代码编译成二进制代码一样，其区别仅是，Java编译的不是二进制，而是中间字节码，且Java编译出来的东西不是直接来运行，而是放到类似真实硬件环境下的虚拟机中运行；反观Python等，它的编译中间字节码过程是智能化的，比Java高级的多——Python的编译中间字节码是通过标准库模块来实现的，Python解析器如果发现须要将源代码（重新）编译成中间字节码，则将加载该标准库模块，用标准库中提供的功能编译源代码。通过以上说明，如果按是否编译中间字节码并放到虚拟机中运行来分类，则Java、C#、Python、Ruby等都是解析型；如果按是否经过编译这一步来分类，那C/C++、Java、Python、C#、Ruby等语言都是编译型，而仅有像Shell（如Bash）这样的语言才是解析型，如此等等。对于判别什么语言是解析型、什么语言是编译型的依据，常用的是判断语言是否需要先编译，如果需要，则判断编译出来的代码能否直接运行。依此依据，Java、C#、Python、Ruby等语言均是解析型的。然而，对于Python而言，由前面所述，Python的编译过程是智能化的，在运行Python程序的过程中，其编译过程就好像不存在一样——假如我们事先不知道编译成中间字节码这个细节的话，那么我们根本感觉不到这一步。由此可知，Python对我们的代码是“实时”反应的：如果第一次运行程序（即还没有经过编译中间字节码这一过程），那么Python会首先编译中间字节码，然后再运行中间字节码；如果已经有中间字节码文件（.pyc文件）了，这时我们修改源代码再运行，那么Python会首先将其重新编译成中间字节码，然后再运行；我们会发现，如果不究其细节的话，整个过程当中，中间字节码文件、编译过程就好像不存在一样，而我们的运行（结果）就好像是对源代码的实时反应一样。而上面的“独立的编译时间”指的是像Java、C/C++那样须要明确地用编译器编译源代码，反观Python，它的编译过程是智能化的，不是“独立的”、“单独划分出来的”。注：上述对Python的编译过程是大致说明，并不十分严格，因为Python程序是否有中间字节码文件，还要看该模块是否是main模块，具体地请参见Python的实现源代码或《Python源码剖析》。另外，重要的一点，如果在Python中使用一个未导入（或未定义）的模块、函数或变量等符号，那么除非Python运行到该行语句时，才会发现该语句的语法错误，否则Python是不会报错的；而对于像C/C++、Java这类的语言，如果有未定义的变量等符号（或该符号没有从其他头文件中include或import进来），那么C/C++、Java在运行前（也即是编译时）就会报错。

### 4、首要的最佳实践规则
    针对功能性文档（你的对象做什么）使用文档字符串；
    针对更加微观的文档（令从费解的是表达式是如何工作的）使用“#”注解。

### 5、sys.path
`sys.path`的设置方法只在修改的Python会话或程序（即进程）中才会持续，在Python结束后不会保留下来。`PYTHONPATH`和`.pth`文件路径配置是保存在操作系统中，而不是执行中的Python程序。

sys.path的组成部分：

    (1) 程序的主目录；
    (2) PYTHONPATH目录（如果已经进行了设置）；
    (3) 标准链接库目录；
    (4) 任何.pth文件的内容（如果存在的话）

注：笔者曾测试了一下（特别声明，本测试并不完全，仅是简单的测试），好像只有位于Python标准模块查找目录下.pth文件才有效；如果一个Python模块查找目录是由.pth文件指定的，那么该目录中.pth文件将无效。笔者的测试：在Python标准模块查找目录下，建立一下.pth文件，在其中指定一个目录（如“tmp_dir”），然后在tmp_dir目录下建立一个.pth文件，并在该文件中指定一个目录（如“tmp_tmp_dir”），结果发现——Python好像并不在“tmp_tmp_dir”目录下查找Python模块。

### 6、迭代器
#### 6.1 文件迭代器（open函数返回一个迭代器）
(1) 所有迭代工具内部工作起来都是在每次迭代中调用`__next__`，并捕捉`StopIterator`异常来确定何时离开。

(2) 逐行读取文本文件的最佳方式就是根本不要去读取；其替代的办法就是，让`for`循环在每轮自动调用`next`从而前进到下一行。

(3) `迭代器在Python中是从C语言的速度运行的，而while循环版本则是通过Python虚拟机运行Python字节码的`。

### 7、Python注释
在Python中，只有一种注释方式——行注释，那就是井号（`#`）。除了字符串或注释中的中的#，其他情况下，#将开启Python注释，即#后的所有字符都是注释。
