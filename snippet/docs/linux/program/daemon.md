
守护进程
=======

## 1、守护进程的特点
    （1）没有控制终端（其控制终端为问号——?）；
    （2）前台进程组ID为-1；
    （3）内核守护进程以无控制终端方式启动；
    （4）所有用户层守护进程都是进程组的组长进程以及会话的首进程，而且是这些进程组和会话中的唯一进程。

## 2、守护进程与普通进程间的关系
守护进程与普通进程本质上没有什么区别，守护进程的特点可以看成是它们之间的差别，其最主要的差别是守护进程没有控制终端。创建守护进程的过程实际上是把一个普通进程按照守护进程的特性改造成守护进程。改造守护进程的过程实际上是**`为进程摆脱控制终端的过程，使之不受控制终端操作的影响`**。

## 3、守护进程编程规则
##### `(1) 首先要做的是调用umask将文件模式创建屏蔽字设置为0`
由继承得来的文件模式创建屏蔽字可能会拒绝某些权限。

##### `(2) 调用fork，然后使父进程退出（exit）`
这样做实现了下面几点：

    第一，如果该守护进程是作为一条简单shell命令启动的，那么父进程终止使得shell认为这条命令已经执行完毕，
         这就使得守护进程没有控制终端；
    第二，子进程继承了父进程的进程组ID，但具有一个新的进程ID，这就保证了子进程不是一个进程组的组长进程，
         以便于下一步调用setsid创建一个会话（原因是，如果一个属于进程组长的进程调用setsid，则将返回出错，
         即进程组长不能调用setsid）。

##### `(3) 调用setsid以创建一个新会话`
调用setsid()，进程将成为会话组长。调用setsid()将创建一个会话期和新的进程组，调用进程为该会话期领导和进程组组长，并且该进程与原来的登录会话和进程组脱离而没有控制终端。

以上三个步骤使调用进程：

    （a）成为新会话的首进程，
    （b）成为一个新进程组的组长进程，
    （c）没有控制终端。

##### `(4) 将当前工作目录更改为根目录`
这是为了防止守护进程占用一个文件系统而不能卸载该文件系统，原因是：从父进程处继承过来的当前工作目录可能在一个装配文件系统中，这将导致该文件系统不能被卸载。

##### `(5) 关闭不再需要的文件描述符`
这使守护进程不再持有从父进程继承过来的某些文件描述符。在网络编程中，如果在父进程中有为子进程打开的描述符，那么这一步一般必须有，原因是：**`fork对网络套接字式的文件描述符仅仅是对其引用计数加1，而最后在子进程调用close关闭该描述符时，也仅仅是把其引用计数减1`**，如果在父进程中没有关闭该描述符，则子进程中的close无法真正的关闭其描述符，这将占用系统资源。同样的道理，在子进程中也要关闭父进程独有的文件描述符。

##### `(6) 某些守护进程打开/dev/null使其具有文件描述符0、1、2`
这样，任何一个试图读标准输入、写标准输出或标准出错的库例程都不会产生任何效果。因为守护进程并不与终端设备相关联，所以不能在终端设备上显示其输出，也无处从交互式用户那里接收输入。即使守护进程是从交互式会话启动的，但因为守护进程是在后台运行的，所以登录会话的终止并不影响守护进程。如果其他用户在同一终端设备上登录，我们也不会在该终端上见到守护进程的输出，用户也不可期望他们在终端上的输入会由守护进程读取。这一步不是必须的，但有些守护进程一般会这么做。

##### `(7) 某些守护进程会处理SIGHUP和SIGCHLD两个信号`
UNIX规定，如果一个没有控制终端的进程调用终端输出/输入函数，将会引发SIGHUP信号。所以必须在信号处理中对SIGHUP进程处理，可以忽略它。但某些守护进程会捕获它，并用于重新加载/读取配置文件。处理SIGCHLD信号并不是必须的。但对于某些进程，特别是服务器进程往往在请求到来时生成子进程处理请求。如果父进程不处理SIGCHLD信号，子进程将成为僵尸进程并占用大量的系统资源。

## 4、守护进程编写的一般程式流程
    (1) 处理SIGHUP信号。
    (2) 处理SIGCHLD信号。
    (3) 关闭所有文件描述符。
    (4) 把文件描述符0、1、2定向到/dev/null设备。
    (5) 改变当前工作目录。
    (6) 重设文件创建掩码。
    (7) 第一次调用fork，以便让守护进程失去进程组的组长一职。
    (8) 脱离控制终端、登录会话和进程组。
    (9) 禁止进程重新打开控制终端。
        当一个没有控制终端的会话期组长的进程调用open()打开一个终端设备时，系统会自动将这个终端作为该进程的控制终端。
        对于这个问题可以通过使进程不再成为会话组长来避免进程重新获得控制终端；
        通过第二次fork()，作为会话期组长的父进程在fork()之后退出，而子进程不再是会话期组长。
    (10)初始化日志文件。
        这一步不是必须的，但是守护进程一般都会有信息需要打印，而守护进程又没有控制终端，因此，
        UNIX系统有一个syslogd守护进程，专门用于处理其他进程的信息输出问题。

注：以上前6步可以放在最后执行（即放在第9步或第10步后面执行），也是一样的。放在前面，是为了让子进程来继承的，以避免在fork时子进程复制一些父进程中没必要的资源信息。

### 一般使普通进程变为守护进程的代码
```c
int make_daemon(void)
{
    pid_t pid;

    /* register the signal SIGHUP and SIGCHLD to process them, when capturing them. */
    signal(SIGHUP, SIG_IGN);
    signal(SIGCHLD, handler);

    /* close all the file descriptions. */

    /* open the file descriptions 0, 1, 2, and redirect them to /dev/null. */
    fd0 = open("/dev/null", O_RDWR);  /* fd0 is equal to 0 */
    fd1 = dup(fd0);                   /* fd1 is equal to 1 */
    fd2 = dup(fd0);                   /* fd2 is equal to 2 */
    if (fd0 != 0 || fd1 != 1 || fd2 != 2){
        printf("Unexpected file descriptions %d %d %d\n", fd0, fd1, fd2);
        return -1;
    }

    /* change the current working directory to the root("/"). */
    chdir("/");

    /* clear the file creation mask. */
    umask(0);

    /* create a child process to lose the process  */
    if ((pid = fork()) == -1){
        perror("fork failed");
        return -1;
    }
    else if (pid != 0){  /* parent process */
        exit(0);
    }

    /* become the session leader to lose the controlling TTY. */
    if (setsid() < 0)   return -1;

    /* Ensure future opens won't allocate controlling TTY.*/
    if ((pid == fork()) == -1){
        perror("fork failed");
        exit(1);
    }
    else if (pid != 0){ /* parent process */
        exit(0);
    }

    /* Initialize the log file. */
    openlog("", LOG_CONS, LOG_DAEMON);

    return 0;
}
```

## 5、守护进程的惯例
在UNIX中，守护进程遵循下列公共惯例：

    (1) 若守护进程使用锁文件，那么该文件通常存放在/var/run目录中。
        锁文件的名字通常是name.pid，其中，name是该守护进程或服务的名字。
    (2) 若守护进程支持配置选项，那么配置文件通常存放在/etc目录中，且配置文件的名字通常是name.conf，
        其中，name是该守护进程或服务的名字。
    (3) 守护进程可用命令行启动，但通常它们是由系统初始化脚本之一（/etc/rc*或/etc/init.d/*）启动的。
        如果在守护进程终止时，应当自动地重新启动它，则我们可在/etc/inittab中为该守护进程包括_respawn记录项，
        这样，init就将重启动该守护进程。
    (4) 若一守护进程有一配置文件，那么当该守护进程启动时，它读该文件，但在此之后一般就不会再查看它。
        若一管理员更改了配置文件，那么该守护进程可能需要被停止，然后再启动，以使配置文件的更改生效。
        为避免此种麻烦，某些守护进程将捕捉SIGHUP信号，当它们接收到该信号时，重读配置文件。
        因为守护进程并不与终端相结合，它们或者是无控制终端的会话首进程，或者是孤儿进程组的成员，
        所以守护进程并不期望接收SIGHUP。于是，它们可以安全地重复使用它。


## 参考资料

《UNIX环境高级编程》（第二版）
