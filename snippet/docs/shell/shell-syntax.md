
第二部分 shell语法
================

## 5 变量
在bash中，我们可以认为变量是没有类型的（这么说其实并不准确）。Bash变量是不区分类型的。本质上，bash变量都是字符串。实际上，我们并不需要为变量事先定义类型。默认情况下，所有变量都被看作字符串并以字符串来存储，即使它们被赋值为数值时也是如此。Shell和一些工具程序会在需要时把数值型字符串置换为对应的数值以对它们进行操作。

变量其实是一个指向实际数据的指针。

### 5.1 自定义变量

#### 5.1.1 变量名
标识符是一串字符序列，该字符序列以一个字母或下划线开头，其后是任意长度的字母、数字或下划线字符。

Bash变量名是一个标识符。变量名的字符长度并无限制。Shell变量可用来保存字符串值，所能保存的字符数同样没有限制。

#### 5.1.2 变量的声明与赋值
在bash里，使用变量之前通常并不需要事先为它们做出声明。我们只是简单地通过使用它们（比如当我们给它们赋初值时）来创建它们。

变量赋值的方式为：`先写变量名称，紧接着写=字符，最后是新值（一般不需要引号，默认为字符串）`。`等号两边不能有任何空格`。`当所赋予的值内含有空白时，应加上引号`。

变量值可以是（而且通常是）空值，也就是不含任何字符。**空值就是null**。一个未初始化的变量将会是“null”值——就是未赋值。空值不代表就是０。在给变量赋值之前就使它，通常都会引起问题。

#### 5.1.3 变量的使用
在引用变量，变量前要加上`美元符号（$）`。作为可选，也可以把变量放在大括号（`{}`）里。一般而言，我们首先使用前一种，只有当变量名必须与其后的字符串区分开来时，才再加上大括号，以便区分出变量名。但这不是必须的，只要不出现错误就行。区别：加上大括号是通用的，去掉大括号后是有限制的。

默认时，变量只有在执行该语句的shell自身内部才是可见的，对父shell和子shell是不可见的；可以把变量传递给在shell内调用的另一个程序（子shell），参见export内置命令。

一旦一个变量被设置，只能使用`unset`内建命令来取消。


## 6 命令解析
在Bash的实现中，Bash对一个命令的解析是有顺序的。

在默认情况下，Bash处于非POSIX模式下，此时对命令的解析顺序如下：

	(1) 关键字。例如：if、for等
	(2) 别名。别名不能与关键字相同，但是可以为关键字定义别名，例如：end=if。
	(3) 函数。如果Bash处于POSIX模式，Bash会优先匹配第（4）步中的特殊内嵌命令，然后再匹配函数。
	(4) 特殊内嵌命令。例如：break、continue等。
		POSIX定义的特殊内嵌命令包括：.（小数点）、:（冒号）、break、continue、eval、
		exec、exit、export、readonly、return、set、shift、times、trap和 unset。
		bash又增加了一个特殊的内嵌命令source。
	(5) 非特殊内嵌命令。例如：cd、test等。
	(6) 脚本和可执行程序。在PATH环境变量指定的目录中进行搜索，返回第一个匹配项。

如果要使用POSIX模式来运行Bash脚本，可以使用以下三个方法：

	(1) 使用—posix选项来启动Bash；
	(2) 在运行Bash之后，执行 set -o posix 命令；
	(3) 使用/bin/sh。

注：在大部分系统上，`/bin/sh`是一个指向Bash的符号链接，但是它为了遵守POSIX标准规范，它所启用的却是POSIX模式。


## 7 管道
```shell
command1 | command2  # command2的标准输入是command1的标准输出
```
注：“管道”会引发command2创建一个新的进程。


## 8 列表（lists）

被 `; & && ||` 连接的一连串命令序列被称为“list”（列表）。

语法　　　　　　|　　　　　　　　作用
--------------|----------------------------------------------------------------------
cmd1 ; cmd2　 | 在同一行上从左到右依次执行多条cmd；只有前条命令执行完毕后（不管是否执行成功），才能执行后一条命令。它的返回值是最后一条被执行的命令的退出状态。
Cmd &        | 把命令cmd放到后台执行；各个在后台执行的命令互不影响。它的返回值是０。
Cmd1 && cmd2 | 逻辑与（AND）。当且仅当cmd1执行成功（退出状态为０）时，才会执行cmd2。它的返回值是最后一条被执行的命令的退出状态。
Cmd1 || cmd2 | 逻辑或（OR）。当且仅当cmd1执行失败（退出状态为非零）时，才会执行cmd2。它的返回值是最后一条被执行的命令的退出状态。
 

## 9 复合命令
复合命令有`() {} (()) [[]] select case if for while until`等几种。其中，后６种在其他编程语言中又称为“`控制结构/语句`“。

### ９.1 ()命令
**语法：**
```shell
(lists)
```

**语义：**

	该命令将引发当前shell产生一个子shell，该命令列表(lists)将在该子shell中执行。
	在命令完成之后，所有影响shell环境的变量参数和内建命令都不再继续有效。
	它的返回值就是命令列表的退出状态。


### ９.2 {}命令
语法：
```shell
{ lists; }
```

**语义：**

	该命令组成一个命令块，该命令块在当前shell中执行。
	在大括号中的命令块必须以一个新行或分号来结束。
	它的返回值是命令块中最后一条被执行的命令的退出状态。
	元字符“{”与“}”是保留字，且必须出现在一个保留字被允许、被许可的地方。


### ９.3 (())命令
**语法：**
```shell
(( expression ))
```

**语义：**

	根据“算术运算”规则对expression进行计算。
	如果计算的结果是个非零值，则它的返回状态是０；否则，为１。
	该命令等价于let “expression”。
	小括号的两个左（右）部分之间不能有空白。


### 9.4 [[]]命令
**语法：**
```shell
[[ expression ]]
```

**语义：**

	根据条件表达式expression的计算结果，返回一个０或１。

**说明：**

	(1) 单词拆分与路径名扩展在[[ ]]中不被执行。
	(2) 使用[[时，大于操作符（>）、小于操作符（<）将根据本地区域设置进行逻辑排序。
	(3) 使用==和!=操作符时，操作符右边的字符串被认为是一个匹配模式，并根据模式匹配规则进行匹配。
	(4) 如果nocasematch选项被启用，匹配将不区分字母大小写。如果比较成立，则返回值为０；否则，返回值为１。
	(5) 匹配模式的任何一部分都应引起来，以促使它作为一个字符串进行匹配。


### 9.５ if语句

#### ９.5.1 语法一
```shell
if condition ; then
    lists
fi
```

**语义：**

	如果条件表达式condition为真，则执行lists；否则，执行if语句后的命令。
 

#### ９.5.2 语法二
```shell
if condition ; then
    lists_1
else
    lists_2
fi
```

**语义：**

	如果条件表达式condition为真，则执行lists_1；否则执行lists_2.
 

#### 9.5.3 语法三
```shell
if condition_1 ; then
    lists_1
elif condition_2 ; then
    lists_2
elif condition_3 ; then
    lists_3
.............
elif condition_n ; then
    lists_n
else
    lists_n+1
fi
```

**语义：**

	如果condition_1为真，则执行lists_1；
	否则，判断condition_2，如果condition_2为真，则执行lists_2；
	否则，判断condition_3，如果condition_3为真，则执行lists_3；
	否则，.......依次类推；
	否则，判断condition_n，如果condition_n为真，则执行lists_n；
	否则，执行lists_n+1。
 
**说明：**

	(1) 整个if...fi语句的返回值就是在then或else后面的最后一个被执行的命令的退出状态。如果无任何命令执行，则返回值为０。
	(2) 在if后面不一定非得是test命令或者昌用于条件判断的中括号结构（[]或[[]]），只要能判断“真”“假”就行。
	(3) “if COMMAND” 结构将会返回COMMAND的退出状态码。


### 9.6 for语句

#### 9.6.1 语法一
```shell
for loop_var in argument_list
do
    lists
done
```

**语义：**

	for循环依次从argument_list参数列表中取出值赋值给loop_var，然后执行lists；依次循环，直到argument_list中的参数被取完。
	For循环里的in列表是可选的。如果省略，shell循环会遍历整个命令行参数。
	返回值是最后一个被执行的命令的退出状态。
	如果argument_list为空，就不会执行任何命令，返回值为0.
 

#### 9.6.2 语法二
```shell
for (( expr1; expr2; expr3 ))
do
    lists
done
```

**语义：**

	首先，根据“算术运算”规则计算算术表达式expr1的值；然后，计算算术表达式expr2的值。
	如果expr2的值为非0（即为真），就执行循环主体lists；否则，结束for循环。
	计算算术表达式expr3；重复执行上述四步操作，直到for循环结束。
	如果算术表达式被省略了，则它的值就如同等于1（即为真）。
	返回值是循环主体中最后一条被执行的命令的退出状态。
	如果expr1，expr2，expr3中任何一个表达式无效，则返回值为false。


### 9.7 while语句

**语法：**
```shell
while  condition
do
    lists
done
```

**语义：**

	while首先会检测condition的逻辑值，如果逻辑值为真，则执行lists；否则，退出while循环，执行while循环后的语句。
	重复上述操作，直到退出while循环。


### 9.8 until语句

**语法：**
```shell
until condition
do
    lists
done
```

**语义：**
	
	until同while，区别之处在于：当condition为假时，while继续循环；当condition为真时，until退出循环。


### 9.9 case语句

**语法：**
```shell
case $variable in
    match_1)
        lists_1
        ;;
    match_2)
        lists_2
        ;;
   ......
   match_n)
       lists_n
       ;;
   *)  # 匹配其他所有模式
       Lists_n+1
       ;;
esac
```

**语义：**

	首先，$variable将先被扩展；然后，从前到后（先列出的在前，后列出的在后）依次匹配给出的模式。
	如果找到了匹配，将执行相应的命令组，且不再匹配其他任何模式，即不执行其他匹配模式下的命令组。

	如果启用nocasematch选项，则匹配规则不再区分大小写；否则，严格区分大小写。
	如果使用 ;; 操作符， 在第一个匹配成功之后，
	如果使用 ;& 来替换 ;;，将继续执行下一个匹配模式的命令组；
	如果使用 ;;& 来替换 ;;，将引发shell去测试下一个匹配模式；若匹配成功，将执行与之关联的命令组。


**说明：**

	(1) 多个模式可以用“|”字符加以分隔以合并成一个模式
	(2) 最后一个模式是可选的，它的表示除列出之外其他的所有情况。
	(3) 如果找到一个匹配之后，不会再尝试其后的匹配。
	  	如果有匹配，整个case语句的返回值为执行序列中最后执行的命令的返回值；如果没有模式匹配，则返回值为0.


### 9.10 select语句

**语法：**
```shell
select  $variable [ in word ]
do
    lists
done
```

**语义：**

待写。


### 9.11 控制流命令
有时需要从某个for或while循环中中断（break）或者继续（continue）执行下一个代码块，或者退出（exit）整个脚本，或者将函数执行结果返回（return）给调用函数的脚本。

#### 9.11.1 break语句
	用于结束包含该语句的循环或case语句。

#### 9.11.2 continue语句
	用于中断当前循环，将控制权转换移动下一次循环。

#### 9.11.3 exit语句
	将退出整个脚本或shell环境。可以在exit命令之后加上一个整数，该整数将作为返回代码发送给系统。
	
#### 9.11.4 return语句
	用于在函数中将数据返回，或返回一个结果或 代码给调用脚本。

#### 9.11.5 true和false
	分别表示真、假。

#### 9.11.6 shift命令
	用于将位置参数向左移动。如$1替换成$2，$3替换成$2，......依次类推。

注：`break`、`continue`和`shift`都可以接受一个可选的整数参数，分别用来指出要中断继续、循环的层数或左移的个数；默认值均是1位。
 

## 10 函数

### 10.1 语法
```shell
function function_name
{
    lists
}
```
或
```shell
function_name( )
{
    lists
}
```

### 10.2 语义
函数名的限制同变量名，参见“标识符”。

当在脚本中编写函数时，必须记住要在使用之前对其进行声明或定义。函数部分必须在调用函数的命令语句之前。不能调用尚不存在的函数。

在函数体中，位置参数（`$1、$2、......、$9、$#、$*、$@`）都是函数的参数。父脚本的参数则临时地被函数参数所掩盖或隐藏。`$0`依旧是父脚本的名称。当函数完成时，原来的命令行参数会恢复。基于历史原因，当它超过9时，就应该用大括号把数字括起来。

函数的执行是在当前的shell脚本当中，而不是再另创建一个子shell。

函数（至少在POSIX shell里）没有提供局部变量。因此所有的函数都与父脚本共享变量。如果在函数中声明的变量前加上`locale`，则该变量只能在该函数和它的调用者之间共享。

在shell函数里，`return`和`exit`都可以退出函数。其中，`exit`会退出整个shell脚本；`return`会返回一个退出值给调用者，而不是直接退出整个shell脚本。

函数会返回整数的退出状态值：**`零表示成功，非零表示失败`**。如果要返回其他的值，函数应设置一个全局性shell变量，或是利用父脚本捕捉它。

函数可以递归的，且没有限制。
