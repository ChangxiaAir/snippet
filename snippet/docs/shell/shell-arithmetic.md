
第四部分 算术计算
==============

## 13 运算符

bash使用来自C程序设计语言的算术运算符，优先级及使用方法等同于在C中。下面运算符的优先级依次从高到低（使用小括号时可不考虑优先级）。

   运算符     |       含义                      |     结合顺序
-------------|--------------------------------|--------------------------------------------------
id++  id--   |  后置递增；后置递减               |     从左到右
++id  --id   |  前置递增；后置递减               |     从右到左
\+  -         |  一元加号（即正）；一元减号（即负）  |     从右到左
!  ~         |  逻辑非；二进制位求反             |     从右到左
\*\*           |  乘幂                          |     从左到右
\*  /  %      |  乘；除；求模（即求余）           |     从左到右
\+  -         |  二元加号；二元减号              |     从左到右
<<  >>       |  按位左移；按位右移              |     从左到右
<= < >= >    |  小于等于；小于；大于等于；大于    |     从左到右
==  !=       |  等于；不等于                   |     从左到右
&            |  按位与                        |     从左到右
^            |  按位异或                      |     从左到右
\|            |  按位或                        |     从左到右
&&           |  逻辑与                        |     从左到右
\|\|           |  逻辑或                        |     从左到右
?:           |  条件表达式                     |     从右到左
=            |  赋值                          |     从右到左
+= -= *= /= %= &=^= \|=  <<= >>= | 复合赋值     |     从右到左
 
**说明：**

	(1) 关系运算符（< <= > >= == !=）产生的数字结果中，1表达为真，0表示为假。
	(2) 对逻辑“与”各“或”运算符而言，任何的非0值都为真，0为假。
	(3) 根据POSIX规定，算术运算符使用的是C的带有正负号的长整数。
	(4) 以0开头的常量被解释为八进制，以0x或0X开头的常量被解释为十六进制。
		所以，数字可以使用 [base #] n 械式，其中，base是一个2到64的用于表示算术基数的十进制数，n是在该基数下的数。
		如果base#省略，基数默认为10。如果base小于36，可以使用小写字母或大写字母来表示10到35的基数。


## 14 算术扩展

### 14.1 $(( expression ))
对expression进行计算，并替换该扩展。

**说明：**

	算术表达式可以进行嵌套。
	如果expression是无效的，bash将打印一条信息来指明失败和没有置换发生的。

### 14.2 let命令
待写。


## 15 条件表达式

### 15.1 语法
```shell
test condition
```
或
```shell
[ condition ]
```

**语义：**

	求condition的值，如果值为“真”（即非零），则返回0退出状态；否则，返回非零退出状态。

### 15.2 文件条件

运算符     |   如果......则为“真”
----------|------------------------------
-a file   |  file文件存在（已经被“弃用“）
-b file   |  file文件存在且是一个块设备文件
-c file   |  file文件存在且是一个字符设备文件
-d file   |  file文件存在且是一个目录
-e file   |  file文件存在
-f file   |  file文件存在且是一个普通文件
-g file   |  file文件存在且file的组ID位（setgid）已被设置
-h file   |  file文件存在且file是一个符号链接
-k file   |  file文件存在且file的粘贴位（sticky）已被设置（不再使用）
-p file   |  file文件存在且是一个命名管道（FIFO）
-r file   |  file文件存在且是一个可读文件（具有可读权限）
-s file   |  file文件存在且长度大于0，即不为空
-t [n]    |  文件描述符n被打开，且与一个终端设备相关联；默认时，n为1
-u file   |  file文件存在且其用户ID位（setuid）已被设置
-w file   |  file文件存在且是一个可写文件（即具有可写权限）
-x file   |  file文件存在且是一个可执行文件（即具有可执行权限）
-G file   |  file文件存在且其组是进程的有效组ID
-L file   |  file文件存在且是一个符号链接。同-h
-N file   |  file文件存在且从file上一次被读取到现在为止，file被修改过
-O file   |  file文件存在且其拥有者是进程的有效用户ID
-S file   |  file文件存在且是一个套接字（socket）
f1 -ef f2 |  文件f1和f2存在且f1和f2是硬链接（具有相同的设备和inode）
f1 -nt f2 |  文件f1比f2新（根据修改日期）；或f1存在，f2不存在
f1 -ot f2 |  文件f1比f2旧；或f1不存在，f2存在

### 15.3 字符串条件

运算符   |   如果......则为“真”
--------|------------------------------------------------
-n s1   | 串s1的长度不为0，即s1非null
-o s1   | s1选项被设置。在set内置命令中描述shell选项
-z s1   | 串s1的长度为0，即s1为null
s1= s2  | 串s1和s2相等。=可用在与POSIX兼容的test命令中
s1== s2 | 串s1和s2相等
s1!= s2 | 串s1和s2不相等
s1 < s2 | 在字母表中（或使用其他排序），串s1比s2小，即s1排在s2的前面。默认的检查是与ASCII字符集中的字符逐个进行比较
s1 > s2 | 在字母表中（或使用其他排序），串s1比s2大，即s1排在s2的后面

### 15.4 数值比较

运算符     |  如果......则为“真”
----------|---------------
n1 -eq n2 |  n1等于n2
n1 -ne n2 |  n1不等于n2
n1 -ge n2 |  n1大于等于n2
n1 -gt n2 |  n1大于n2
n1 -le n2 |  n1小于等于n2
n1 -lt n2 |  n1小于n2

### 15.5 组合形式

#### 15.5.1 !condition
	如果condition为假，则结果为“真”
 
#### 15.5.2  condition_1 -a condition_2
	如果condition_1和condition_2都为真，则结果为“真”。等同于&&

#### 15.5.3  condition_1 -o condition_2
	如果condition_1和condition_2中有一个为“真”，则结果为“真”。等同于||

注：`-a`、`-a`与`&&`、`||`相似，便有区别：`-a`、`-o`用在双中括号（`[]`）中，而`&&`、`||`用在其外。
如：
```shell
[ condition_1 ] && [ condition_2 ]
[ condition_1 -a condition_2 ]
```
